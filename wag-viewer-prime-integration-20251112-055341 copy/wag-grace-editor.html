<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WAG Grace Editor - Machine of Loving Grace</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='80' font-size='80'>ðŸ’š</text></svg>">
    <style>
        :root {
            --bg-main: #0a0a0a;
            --bg-secondary: #151515;
            --bg-tertiary: #1f1f1f;
            --text-primary: #e8e8e8;
            --text-secondary: #b8b8b8;
            --border-primary: #2a2a2a;
            --accent: #ffd700;
            --success: #0f0;
            --error: #f33;
        }
        :root[data-theme="light"] {
            --bg-main: #ffffff;
            --bg-secondary: #f6f8fa;
            --bg-tertiary: #eaeef2;
            --text-primary: #24292f;
            --text-secondary: #57606a;
            --border-primary: #d0d7de;
            --accent: #0969da;
            --success: #0a0;
            --error: #d1242f;
        }
        :root[data-theme="green"] {
            --bg-main: #0d1117;
            --bg-secondary: #0a1f1a;
            --bg-tertiary: #0f2920;
            --text-primary: #aff5b4;
            --text-secondary: #7ee787;
            --border-primary: #1f6feb;
            --accent: #3fb950;
            --success: #0f0;
            --error: #f85149;
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: 'Courier New', monospace;
            background: var(--bg-main);
            color: var(--text-primary);
            height: 100vh;
            display: grid;
            grid-template-rows: 1fr;
            grid-template-columns: 1fr 1fr;  /* Equal 50/50 split */
            overflow: hidden;
            padding-top: 44px;
            padding-bottom: 44px;
        }
        
        /* Mobile/Tablet: Stack vertically */
        @media (max-width: 900px) {
            body {
                grid-template-columns: 1fr !important;
                grid-template-rows: minmax(300px, 1fr) minmax(300px, 1fr) !important;
            }
            #editor-panel {
                grid-row: 2 !important;
                grid-column: 1 !important;
                width: 100% !important;
                max-width: 100% !important;
                display: flex !important;
                visibility: visible !important;
                border-right: none !important;
                border-top: 2px solid var(--accent) !important;
            }
            #viewer-panel {
                grid-row: 1 !important;
                grid-column: 1 !important;
                width: 100% !important;
                max-width: 100% !important;
                display: flex !important;
                visibility: visible !important;
            }
        }
        /* Header - FIXED position like Bronze */
        #header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 44px;
            background: linear-gradient(180deg, var(--bg-tertiary) 0%, var(--bg-secondary) 100%);
            border-bottom: 1px solid var(--border-primary);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 12px;
            box-shadow: 0 1px 0 rgba(255,255,255,0.05);
            z-index: 1000;
        }
        #header-left {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        #file-name {
            font-size: 13px;
            color: var(--accent);
            font-weight: 600;
        }
        #header-center {
            display: flex;
            gap: 6px;
            align-items: center;
        }
        .mode-btn {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-primary);
            color: var(--text-secondary);
            font-size: 14px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }
        .mode-btn:hover {
            background: var(--bg-secondary);
            color: var(--text-primary);
            transform: translateY(-1px);
        }
        .mode-btn.active {
            background: var(--accent);
            color: var(--bg-main);
            border-color: var(--accent);
        }
        .corner-btn {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-primary);
            color: var(--text-secondary);
            font-size: 14px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }
        .corner-btn:hover {
            background: var(--bg-secondary);
            color: var(--text-primary);
            transform: translateY(-1px);
        }
        /* Footer - FIXED position like Bronze */
        #footer {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 44px;
            background: var(--bg-secondary);
            border-top: 1px solid var(--border-primary);
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 0 16px;
            z-index: 1000;
        }
        @media (max-width: 900px) {
            #footer {
                font-size: 9px;
                padding: 0 6px;
                gap: 4px;
            }
            #status-text {
                flex: 1;
                overflow: hidden;
                text-overflow: ellipsis;
                white-space: nowrap;
                min-width: 0;
            }
        }
        #scene-selector {
            padding: 6px 12px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-primary);
            border-radius: 4px;
            color: var(--text-primary);
            font-size: 11px;
            font-family: 'Courier New', monospace;
            cursor: pointer;
            transition: all 0.2s;
        }
        .footer-corner-btn {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-primary);
            color: var(--text-secondary);
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            flex-shrink: 0;
        }
        .footer-corner-btn:hover {
            background: var(--bg-secondary);
            color: var(--text-primary);
            transform: translateY(-1px);
        }
        #scene-selector:hover {
            border-color: var(--accent);
        }
        #status-text {
            color: var(--accent);
            flex: 1;
        }
        #model-stats {
            color: var(--text-secondary);
        }
        /* Editor Panel - left column (50% width, equal to viewer) */
        #editor-panel {
            grid-row: 1;
            grid-column: 1;
            background: var(--bg-secondary);
            border-right: 1px solid var(--border-primary);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            min-width: 0;  /* Allow flex shrink */
        }
        #editor-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 12px;
            overflow: hidden;
        }
        .section-title {
            font-size: 11px;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 700;
            margin-top: 8px;
        }
        #editor-area {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 16px;
        }
        /* Panel Header - Above Editor */
        .panel-header {
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-primary);
            padding: 6px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            height: 36px;
        }
        .panel-header-left, .panel-header-right {
            display: flex;
            gap: 4px;
            align-items: center;
        }
        .panel-btn {
            padding: 4px 10px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-primary);
            border-radius: 4px;
            color: var(--text-secondary);
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s;
            font-family: 'Courier New', monospace;
        }
        .panel-btn:hover {
            background: var(--bg-main);
            color: var(--text-primary);
            border-color: var(--accent);
        }
        
        /* Editor Scroll Container */
        #editor-scroll-container {
            display: flex;
            width: 100%;
            height: calc(100% - 36px);
            overflow: hidden;
        }
        
        /* Line-based Editor */
        #mpd-editor {
            flex: 1;
            height: 100%;
            overflow-y: auto;
            background: var(--bg-main);
            padding: 12px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.6;
        }
        
        .editor-line {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 4px 8px;
            border-left: 3px solid transparent;
            transition: all 0.15s;
            min-height: 28px;
        }
        .editor-line:hover {
            background: rgba(255, 255, 255, 0.05);
            cursor: pointer;
        }
        .editor-line.locked {
            background: rgba(255, 215, 0, 0.15);
            border-left: 3px solid var(--accent);
        }
        .editor-line.selected {
            background: rgba(44, 194, 255, 0.2) !important;
            border-left: 3px solid var(--accent) !important;
            box-shadow: inset 0 0 0 1px var(--accent);
        }
        .editor-line.compiling {
            background: rgba(255, 215, 0, 0.15);
            border-left-color: var(--accent);
            animation: compileWave 0.6s cubic-bezier(0.4, 0, 0.2, 1);
        }
        @keyframes compileWave {
            0% { background: rgba(255, 215, 0, 0.15); transform: translateX(-10px); }
            100% { background: rgba(255, 215, 0, 0); transform: translateX(0); }
        }
        .editor-line.highlighted {
            background: rgba(255, 215, 0, 0.2);
            border-left-color: #ffd700;
            animation: pulse 1s ease-in-out 2;
        }
        @keyframes pulse {
            0%, 100% { background: rgba(255, 215, 0, 0.2); }
            50% { background: rgba(255, 215, 0, 0.35); }
        }
        .editor-line.locked .line-content {
            color: #fa0;
            font-weight: 600;
        }
        .editor-line.missing-part {
            background: rgba(255, 105, 180, 0.15) !important;
            border-left: 3px solid #ff69b4 !important;
            position: relative;
            animation: errorPulse 2s ease-in-out infinite;
        }
        .editor-line.missing-part::after {
            content: 'ðŸ’” MISSING';
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            color: #ff69b4;
            font-size: 11px;
            font-weight: 700;
            background: rgba(0,0,0,0.7);
            padding: 2px 8px;
            border-radius: 4px;
        }
        @keyframes errorPulse {
            0%, 100% { background: rgba(255, 105, 180, 0.15); }
            50% { background: rgba(255, 105, 180, 0.25); }
        }
        
        .line-checkbox {
            width: 16px;
            height: 16px;
            cursor: pointer;
            flex-shrink: 0;
            accent-color: var(--accent);
            opacity: 1 !important;
            appearance: auto !important;
            -webkit-appearance: checkbox !important;
        }
        .editor-line.locked .line-checkbox {
            accent-color: #fa0;
        }
        
        .line-number {
            min-width: 32px;
            text-align: right;
            color: var(--text-tertiary);
            font-size: 10px;
            flex-shrink: 0;
            user-select: none;
        }
        
        .line-content {
            flex: 1;
            color: var(--text-primary);
            font-family: 'Courier New', monospace;
            font-size: 12px;
            outline: none;
            white-space: pre;
            font-weight: 500;
        }
        .line-content:focus {
            background: rgba(255, 215, 0, 0.08);
            border-radius: 2px;
        }
        .line-content.comment {
            color: var(--text-tertiary);
            font-style: italic;
            font-weight: 400;
        }
        .line-content.part {
            color: var(--text-primary);
            font-weight: 600;
        }
        .line-content.disabled {
            color: var(--text-tertiary);
            text-decoration: line-through;
            opacity: 0.4;
        }
        .editor-line.file-line {
            background: rgba(255, 215, 0, 0.05);
        }
        .editor-line.file-line .line-content {
            color: var(--accent);
            font-weight: 700;
            text-decoration: underline;
        }
        .editor-line.step-line .line-content {
            color: #0ff;
            font-weight: 600;
        }
        
        /* Grace Error Panel */
        #grace-error-panel {
            position: fixed;
            bottom: 44px;
            left: 0;
            right: 50%;
            max-height: 200px;
            background: linear-gradient(180deg, rgba(255, 105, 180, 0.95) 0%, rgba(220, 20, 60, 0.95) 100%);
            border-top: 2px solid #ff1493;
            overflow-y: auto;
            z-index: 900;
            transform: translateY(100%);
            transition: transform 0.3s ease;
            display: none;
        }
        #grace-error-panel.visible {
            display: block;
            transform: translateY(0);
        }
        .grace-error-header {
            padding: 8px 12px;
            background: rgba(0,0,0,0.3);
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 700;
            color: #fff;
        }
        .grace-error-item {
            padding: 8px 12px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            cursor: pointer;
            color: #fff;
            transition: background 0.2s;
        }
        .grace-error-item:hover {
            background: rgba(255, 255, 255, 0.15);
        }
        .grace-error-line {
            font-weight: 700;
            color: #ffff00;
        }
        .grace-error-copy {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: #fff;
            padding: 4px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }
        .grace-error-copy:hover {
            background: rgba(255, 255, 255, 0.3);
        }
        @media (max-width: 900px) {
            #grace-error-panel {
                right: 0;
                bottom: 0;
            }
        }
        
        /* Minimap */
        #mpd-minimap {
            width: 20px;
            height: 100%;
            background: var(--bg-tertiary);
            border-left: 1px solid var(--border-primary);
            overflow: hidden;
            position: relative;
            flex-shrink: 0;
        }
        .mpd-minimap-strip {
            width: 100%;
            cursor: pointer;
            border-bottom: 1px solid rgba(0,0,0,0.2);
            transition: background 0.2s;
        }
        .mpd-minimap-strip:hover {
            background: rgba(255,255,255,0.2) !important;
        }
        .mpd-minimap-strip.part { background: #4a9eff; }
        .mpd-minimap-strip.comment { background: #555; }
        .mpd-minimap-strip.empty { background: #1a1a1a; }
        .mpd-minimap-strip.locked { background: #fa0; }
        
        /* 2D Grid View */
        #grid-2d {
            width: 100%;
            height: 100%;
            background: var(--bg-main);
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            grid-template-rows: repeat(9, 1fr);
            gap: 2px;
            padding: 20px;
        }
        .grid-cell {
            background: var(--bg-main);
            border: 1px solid var(--border-primary);
            transition: all 0.2s;
        }
        .grid-cell.occupied {
            background: var(--accent);
            border-color: rgba(255, 215, 0, 0.5);
        }
        .grid-cell.selected {
            box-shadow: inset 0 0 0 2px #00ff00, 0 0 8px #00ff00;
            animation: pulse-grid 1s ease-in-out infinite;
        }
        @keyframes pulse-grid {
            0%, 100% { box-shadow: inset 0 0 0 2px #00ff00, 0 0 8px #00ff00; }
            50% { box-shadow: inset 0 0 0 3px #00ff00, 0 0 12px #00ff00; }
        }
        .grid-cell:hover {
            background: rgba(255, 215, 0, 0.2);
            border-color: var(--accent);
        }
        
        /* Minimap grid cells */
        .minimap-cell {
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
        }
        .minimap-cell.occupied {
            background: var(--accent);
            box-shadow: 0 0 2px rgba(255, 215, 0, 0.8);
        }
        
        /* Scene dots */
        #scene-dots {
            z-index: 10;
        }
        
        /* Paste Zone Modal */
        #paste-zone {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80%;
            max-width: 600px;
            height: 60%;
            background: var(--bg-secondary);
            border: 2px dashed var(--accent);
            border-radius: 8px;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 5000;
            padding: 24px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.8);
        }
        #paste-zone.active {
            display: flex;
        }
        #paste-zone textarea {
            width: 100%;
            height: 100%;
            background: var(--bg-main);
            border: 1px solid var(--border-primary);
            color: var(--text-primary);
            font-family: 'Courier New', monospace;
            font-size: 12px;
            padding: 12px;
            resize: none;
            margin-bottom: 16px;
        }
        .paste-buttons {
            display: flex;
            gap: 12px;
        }
        
        #render-btn {
            padding: 10px;
            background: var(--accent);
            color: var(--bg-main);
            border: none;
            border-radius: 4px;
            font-weight: 700;
            font-size: 12px;
            letter-spacing: 1px;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
        }
        #render-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(255, 215, 0, 0.3);
        }
        #render-btn:active { transform: translateY(0); }
        .char-count {
            font-size: 10px;
            color: var(--text-secondary);
            text-align: right;
        }
        #search {
            padding: 8px;
            border-radius: 4px;
            border: 1px solid var(--border-primary);
            background: var(--bg-main);
            color: var(--text-primary);
            font-size: 11px;
        }
        #search:focus {
            outline: 1px solid var(--accent);
            border-color: var(--accent);
        }
        #stats {
            font-size: 10px;
            color: var(--text-secondary);
            padding: 4px 0;
        }
        #model-list { display: flex; flex-direction: column; gap: 8px; }
        .model-item {
            padding: 8px;
            border-radius: 4px;
            background: var(--bg-tertiary);
            border: 1px solid transparent;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 11px;
        }
        .model-item:hover {
            border-color: var(--accent);
            transform: translateX(2px);
        }
        .model-item.active {
            border-color: var(--accent);
            background: rgba(255, 215, 0, 0.1);
        }
        .model-title { font-weight: 600; font-size: 14px; }
        .model-meta { font-size: 12px; color: #aaa; margin-top: 4px; }
        .scene-item:hover {
            border-color: var(--accent);
            transform: translateX(2px);
        }
        .scene-item.active {
            border-color: var(--accent) !important;
            background: rgba(255, 215, 0, 0.1) !important;
        }
        #new-scene-btn:hover {
            background: var(--bg-secondary);
            border-color: var(--accent);
            color: var(--text-primary);
        }
        /* Viewer Panel - right column (50% width, equal to editor) */
        #viewer-panel {
            grid-row: 1;
            grid-column: 2;
            background: var(--bg-main);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            min-width: 0;  /* Allow flex shrink */
        }
        
        /* On mobile, add top border instead of left border */
        @media (max-width: 900px) {
            #editor-panel {
                border-right: none !important;
                border-top: 2px solid var(--accent) !important;
            }
            /* Hide scene name on mobile to save space */
            #scene-name {
                display: none !important;
            }
            /* Make buttons smaller on mobile */
            .panel-btn, .corner-btn, .mode-btn {
                font-size: 11px !important;
                padding: 4px 8px !important;
            }
        }
        #viewer-content {
            flex: 1;
            position: relative;
            overflow: hidden;
        }
        
        /* Mobile: Fix control bar positioning and visibility */
        @media (max-width: 900px) {
            #viewer-panel > div:first-of-type {
                position: sticky !important;
                top: 0 !important;
                z-index: 200 !important;
                flex-wrap: wrap !important;
            }
            
            #scene-dots-vertical {
                right: 5px !important;
                top: 60px !important;
                padding: 4px !important;
            }
            #minimap {
                right: 5px !important;
                top: 100px !important;
                width: 90px !important;
                height: 90px !important;
            }
        }
        #viewer { width: 100%; height: 100%; }
        #loading {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.92);
            z-index: 10000;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(8px);
            opacity: 0;
            transition: opacity 0.15s ease-out;
        }
        #loading.active {
            display: flex !important;
            opacity: 1;
            animation: breathe 2s ease-in-out infinite;
        }
        @keyframes breathe {
            0%, 100% { backdrop-filter: blur(8px); }
            50% { backdrop-filter: blur(12px); }
        }
        .loading-content {
            background: linear-gradient(135deg, rgba(10, 35, 50, 0.95), rgba(5, 20, 30, 0.95));
            padding: 40px 60px;
            border-radius: 16px;
            border: 2px solid var(--accent);
            box-shadow: 0 0 40px rgba(42, 193, 255, 0.3), 
                        0 8px 32px rgba(0,0,0,0.8),
                        inset 0 1px 0 rgba(255,255,255,0.1);
            text-align: center;
            animation: float 3s ease-in-out infinite;
            position: relative;
            overflow: hidden;
        }
        .loading-content::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, 
                transparent 30%, 
                rgba(42, 193, 255, 0.05) 50%, 
                transparent 70%);
            animation: shimmer 3s linear infinite;
        }
        @keyframes float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-8px); }
        }
        @keyframes shimmer {
            0% { transform: translate(-50%, -50%) rotate(0deg); }
            100% { transform: translate(-50%, -50%) rotate(360deg); }
        }
        .loading-spinner {
            width: 80px;
            height: 80px;
            border: 5px solid transparent;
            border-top: 5px solid var(--accent);
            border-right: 5px solid rgba(42, 193, 255, 0.3);
            border-radius: 50%;
            animation: spin 0.8s linear infinite, pulse 1.5s ease-in-out infinite;
            margin: 0 auto 20px;
            box-shadow: 0 0 20px rgba(42, 193, 255, 0.4),
                        inset 0 0 20px rgba(42, 193, 255, 0.2);
            position: relative;
        }
        .loading-spinner::after {
            content: '';
            position: absolute;
            top: 5px;
            left: 5px;
            right: 5px;
            bottom: 5px;
            border: 3px solid transparent;
            border-bottom: 3px solid rgba(42, 193, 255, 0.6);
            border-left: 3px solid rgba(42, 193, 255, 0.3);
            border-radius: 50%;
            animation: spin 1.2s linear infinite reverse;
        }
        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.1); opacity: 0.8; }
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .loading-text {
            font-size: 18px;
            color: var(--accent);
            margin-bottom: 12px;
            font-weight: 700;
            text-shadow: 0 0 10px rgba(42, 193, 255, 0.5),
                         0 0 20px rgba(42, 193, 255, 0.3);
            animation: textPulse 2s ease-in-out infinite;
            letter-spacing: 1px;
            position: relative;
            z-index: 1;
        }
        .loading-subtext {
            font-size: 13px;
            color: rgba(42, 193, 255, 0.7);
            animation: textPulse 2s ease-in-out infinite 0.3s;
            position: relative;
            z-index: 1;
        }
        @keyframes textPulse {
            0%, 100% { 
                opacity: 0.8;
                transform: translateY(0);
            }
            50% { 
                opacity: 1;
                transform: translateY(-2px);
            }
        }
        .loading-progress {
            margin-top: 20px;
            width: 100%;
            height: 4px;
            background: rgba(42, 193, 255, 0.1);
            border-radius: 2px;
            overflow: hidden;
            position: relative;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.3);
        }
        .loading-progress::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            background: linear-gradient(90deg, 
                transparent 0%,
                var(--accent) 50%,
                transparent 100%);
            animation: scanProgress 2s ease-in-out infinite;
            width: 50%;
        }
        @keyframes scanProgress {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(300%); }
        }
        #info-panel {
            position: absolute;
            right: 20px;
            top: 20px;
            width: 280px;
            padding: 15px;
            border-radius: 10px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #1e90c2;
            backdrop-filter: blur(8px);
        }
        #info-panel h2 { font-size: 16px; margin-bottom: 10px; color: #8ae4ff; }
        .info-row { font-size: 12px; margin-bottom: 6px; }
        .label { color: #999; display: inline-block; width: 70px; }
        #controls {
            position: absolute;
            left: 20px;
            bottom: 20px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            background: rgba(0, 0, 0, 0.75);
            border: 1px solid #1e90c2;
            border-radius: 8px;
            padding: 12px;
        }
        .control-row { display: flex; gap: 6px; flex-wrap: wrap; }
        #controls button {
            background: #1e90c2;
            color: #03131b;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.2s;
        }
        #controls button:hover { background: #28b3f5; }
        .toggle-button.active { background: #2cc2ff; color: #03131b; }
        .empty-state { font-size: 13px; color: #777; margin-top: 10px; }
        #manual-loader {
            background: #101010;
            border: 1px solid #2b2b2b;
            border-radius: 8px;
            padding: 12px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        #manual-loader h2 { font-size: 14px; color: #8ae4ff; }
        #manual-text {
            width: 100%;
            min-height: 80px;
            background: #050505;
            border: 1px solid #333;
            border-radius: 4px;
            color: #e8e8e8;
            padding: 8px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            resize: vertical;
        }
        .manual-actions { display: flex; gap: 8px; flex-wrap: wrap; }
        #manual-loader button,
        #manual-loader label.file-label {
            background: #1e90c2;
            color: #03131b;
            border: none;
            padding: 6px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            text-align: center;
        }
        #manual-loader button:hover,
        #manual-loader label.file-label:hover { background: #28b3f5; }
        #manual-file { display: none; }
        #manual-path {
            width: 100%;
            padding: 6px 8px;
            border-radius: 4px;
            border: 1px solid #333;
            background: #0e0e0e;
            color: #fefefe;
            font-size: 12px;
        }
        #info-panel .value { color: #e8e8e8; }
        #info-panel .info-highlight { color: #8ae4ff; font-weight: bold; }
    </style>
</head>
<body>
    <!-- Header: 4 corners + center -->
    <header id="header">
        <div id="header-left">
            <button class="corner-btn" id="help-btn" title="Help">?</button>
            <button class="corner-btn" id="mobile-paste-btn" title="ðŸ“‹ Paste MPD from Phone" style="background: var(--accent); color: var(--bg-main); font-weight: 700; margin-left: 8px;">ðŸ“‹ PASTE</button>
            <span id="file-name" style="font-size: 14px; font-weight: 600; margin-left: 12px;">Scene 1</span>
        </div>
        <div id="header-center">
            <div style="display: flex; gap: 4px; align-items: center; padding: 0 8px; border-right: 1px solid var(--border-primary); margin-right: 8px;">
                <button class="mode-btn" id="undo-btn" title="Undo">â†¶</button>
                <button class="mode-btn" id="redo-btn" title="Redo">â†·</button>
            </div>
            <button class="mode-btn" id="clear-btn" title="Clear">âˆ…</button>
            <button class="mode-btn active" id="select-mode" title="Select">âŒ–</button>
            <button class="mode-btn" id="lock-mode" title="Lock">âŠ—</button>
        </div>
        <button class="corner-btn" id="theme-btn" title="Theme: Dark">ðŸŒ™</button>
    </header>
    
    <!-- Editor Panel (left) -->
    <section id="editor-panel">
        <div class="panel-header">
            <div class="panel-header-left">
                <button class="panel-btn" id="mpd-undo-btn" title="Undo">â†¶</button>
                <button class="panel-btn" id="mpd-redo-btn" title="Redo">â†·</button>
                <button class="panel-btn" id="new-mpd-btn" title="New MPD">New</button>
                <button class="panel-btn" id="clear-mpd-btn" title="Discard">Discard</button>
            </div>
            <div class="panel-header-right">
                <button class="panel-btn" id="copy-all-btn" title="Copy All">âŽ˜</button>
                <button class="panel-btn" id="render-btn" title="Force Render">âŸ³</button>
            </div>
        </div>
        <div id="editor-scroll-container">
            <div id="mpd-editor"></div>
            <div id="mpd-minimap"></div>
        </div>
    </section>    
    <!-- Viewer Panel (right) -->
    <section id="viewer-panel">
        <!-- Viewer Mode Tabs + Controls (thin bar above grid) -->
        <div style="background: var(--bg-secondary); border-bottom: 1px solid var(--border-primary); padding: 6px; display: flex; justify-content: space-between; align-items: center;">
            <div style="display: flex; gap: 6px; align-items: center;">
                <button class="panel-btn active" id="mode-3d-tab">3D</button>
                <button class="panel-btn" id="mode-2d-tab">2D</button>
                <div style="width: 1px; height: 16px; background: var(--border-primary); margin: 0 4px;"></div>
                <button class="panel-btn" id="spin-quick" title="Auto Spin">S</button>
                <button class="panel-btn" id="reset-quick" title="Reset View">âŒ–</button>
            </div>
            <div style="flex: 1;"></div>
            <div style="display: flex; gap: 4px; align-items: center;">
                <button class="panel-btn" id="wire-quick" title="Wireframe">W</button>
                <button class="panel-btn active" id="axes-quick" title="Axes">A</button>
                <button class="panel-btn active" id="grid-quick" title="Grid">G</button>
                <button class="panel-btn" id="flipy-quick" title="Flip Y">Y</button>
                <div style="width: 1px; height: 16px; background: var(--border-primary); margin: 0 4px;"></div>
                <input type="color" id="bg-color-picker" value="#0a0a0a" title="Background Color" style="width: 30px; height: 20px; border: 1px solid var(--border-primary); cursor: pointer; background: transparent; padding: 0;">
                <button class="panel-btn active" id="minimap-toggle" title="Toggle Minimap">â–£</button>
                <button class="panel-btn" id="screenshot-btn" title="Screenshot (4:3 + JSON)">IMG</button>
            </div>
        </div>
        
        <div id="viewer-content">
            <div id="viewer" style="display: block;"></div>
            <!-- 2D Grid View -->
            <div id="grid-2d" style="display: none;"></div>
            <!-- Loading Indicator (full-screen overlay) -->
            <div id="loading">
                <div class="loading-content">
                    <div class="loading-spinner"></div>
                    <div class="loading-text">Loading...</div>
                    <div class="loading-subtext">Please wait...</div>
                    <div class="loading-progress"></div>
                </div>
            </div>
            
            <!-- Scene dots (vertical strip on right edge) -->
            <div id="scene-dots-vertical" style="position: absolute; top: 10px; right: 10px; display: flex; flex-direction: column; gap: 6px; align-items: center; padding: 6px; background: rgba(0,0,0,0.7); border: 1px solid var(--border-primary); border-radius: 4px; z-index: 100;">
                <!-- Dots populated dynamically -->
            </div>
            
            <!-- Minimap (below scene dots on right edge) -->
            <div id="minimap" style="position: absolute; top: 140px; right: 10px; width: 120px; height: 120px; background: rgba(0,0,0,0.8); border: 2px solid var(--accent); border-radius: 4px; display: block; padding: 4px; z-index: 100;">
                <div style="font-size: 9px; color: var(--accent); text-align: center; margin-bottom: 2px; font-weight: 700;">MAP</div>
                <div id="minimap-grid" style="display: grid; grid-template-columns: repeat(9, 1fr); gap: 1px; height: calc(100% - 14px);"></div>
            </div>
        </div>
    </section>
    
    <!-- Footer: 4 corners -->
    <footer id="footer">
        <button class="footer-corner-btn" id="import-export-btn" title="Import/Export">â‡„</button>
        
        <div style="flex: 1; display: flex; align-items: center; justify-content: center; gap: 12px;">
            <select id="scene-selector" style="min-width: 200px;">
                <option value="0">Scene 1</option>
            </select>
            <span id="status-text">Ready</span>
        </div>
        
        <div style="display: flex; gap: 8px; align-items: center;">
            <span id="model-stats">No model loaded</span>
            <span id="lib-status" style="font-size: 10px; color: var(--text-tertiary);">Library: Loading...</span>
        </div>
        
        <button class="footer-corner-btn" id="new-scene-btn" title="New Scene">+</button>
    </footer>
    
    <!-- Grace Error Panel (slides up from bottom) -->
    <div id="grace-error-panel">
        <div class="grace-error-header">
            <span>ðŸ’š Grace Report - Missing Parts</span>
            <div style="display: flex; gap: 8px;">
                <button class="grace-error-copy" onclick="copyGraceErrors()">ðŸ“‹ COPY</button>
                <button class="grace-error-copy" onclick="closeGracePanel()">âœ• CLOSE</button>
            </div>
        </div>
        <div id="grace-error-list"></div>
    </div>
    
    <!-- Paste Zone (overlay) -->
    <div id="paste-zone">
        <h3 style="color:var(--accent);margin-bottom:12px;">Paste MPD Content</h3>
        <textarea id="paste-textarea" placeholder="Paste entire MPD file here..."></textarea>
        <div class="paste-buttons">
            <button class="panel-btn" id="paste-load-btn" style="padding: 8px 20px;">Load</button>
            <button class="panel-btn" id="paste-cancel-btn" style="padding: 8px 20px;">Cancel</button>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="./examples/js/loaders/LDrawLoader.js?v=11"></script>
    <script src="./beta-prime-engine.js"></script>
    <script>
    const AI_FILE_PATTERN = /^ai[\s_\-\(\.]?/i;
    const LIBRARY_BASE = './ldraw/';
    const ROOT_PREFIX_FROM_LIBRARY = '../';

    // Global error log (Bronze-style)
    const ERROR_LOG = [];
    
    // Grace Editor: Track missing parts for graceful rendering
    const MISSING_PARTS = new Map(); // partName -> { lineNumbers: [], count: number }
    const PLACEHOLDER_CACHE = new Map(); // Store created placeholder geometries
    let graceSystemReady = false;
    
    function logError(context, error) {
        const entry = {
            time: new Date().toISOString(),
            context: context,
            message: error.message || String(error),
            stack: error.stack || '',
            line: error.lineNumber || null
        };
        ERROR_LOG.push(entry);
        console.error(`[${context}]`, error);
        
        // Force update of error warning button
        setTimeout(() => updateErrorWarning(), 100);
    }
    
    function updateErrorWarning() {
        let errorBtn = document.getElementById('error-warning-btn');
        if (!errorBtn) {
            errorBtn = document.createElement('button');
            errorBtn.id = 'error-warning-btn';
            errorBtn.className = 'corner-btn';
            errorBtn.style.cssText = 'background: var(--error); color: #000; font-weight: 700; margin-left: 4px;';
            errorBtn.title = 'Console Errors - Click to copy';
            errorBtn.textContent = `âš  ${ERROR_LOG.length}`;
            
            errorBtn.addEventListener('click', () => {
                const logText = ERROR_LOG.map(e => 
                    `[${e.time}] ${e.context}: ${e.message}\n${e.stack}`
                ).join('\n\n');
                
                navigator.clipboard.writeText(logText).then(() => {
                    const statusText = document.getElementById('status-text');
                    if (statusText) {
                        statusText.textContent = `ðŸ“‹ Copied ${ERROR_LOG.length} errors!`;
                        statusText.style.color = 'var(--error)';
                        statusText.style.fontWeight = '700';
                        setTimeout(() => {
                            statusText.textContent = 'Ready';
                            statusText.style.color = '';
                            statusText.style.fontWeight = '';
                        }, 2000);
                    }
                });
            });
            
            const themeBtn = document.getElementById('theme-btn');
            if (themeBtn && themeBtn.parentNode) {
                themeBtn.parentNode.insertBefore(errorBtn, themeBtn.nextSibling);
            }
        } else {
            errorBtn.textContent = `âš  ${ERROR_LOG.length}`;
            errorBtn.style.display = ERROR_LOG.length > 0 ? 'block' : 'none';
        }
    }

    const STATE = {
        scenes: [],
        activeSceneIdx: 0,
        viewer: null,
        autoSpin: false,
        diagnostics: {
            grid: true,
            axes: true,
            flipY: false,
            wireframe: false,
            showEdges: true,
            backfaceCull: false
        },
        libraryFileMap: null  // Still need this for LDraw parts
    };
    
    let editorContainer = null;  // Will be set on init
    let editorLines = [];  // Current lines array
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // GRACE EDITOR: Graceful Error Handling System
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function createPlaceholder(partName, position = {x: 0, y: 0, z: 0}) {
        // Safety check: THREE must be loaded
        if (typeof THREE === 'undefined') {
            console.warn('ðŸ’š THREE.js not loaded yet, deferring placeholder creation');
            return null;
        }
        
        // Check cache first
        if (PLACEHOLDER_CACHE.has(partName)) {
            return PLACEHOLDER_CACHE.get(partName).clone();
        }
        
        // Create a loving pink cube with label
        const geometry = new THREE.BoxGeometry(20, 20, 20);
        const material = new THREE.MeshBasicMaterial({
            color: 0xff69b4,  // Hot pink
            transparent: true,
            opacity: 0.6,
            wireframe: false
        });
        const cube = new THREE.Mesh(geometry, material);
        
        // Add wireframe edges
        const edges = new THREE.EdgesGeometry(geometry);
        const line = new THREE.LineSegments(edges, 
            new THREE.LineBasicMaterial({ color: 0xff1493, linewidth: 2 })
        );
        cube.add(line);
        
        // Store in cache
        PLACEHOLDER_CACHE.set(partName, cube);
        
        console.log(`ðŸ’š Created placeholder for missing part: ${partName}`);
        return cube.clone();
    }
    
    function trackMissingPart(partName, lineNumber) {
        if (!MISSING_PARTS.has(partName)) {
            MISSING_PARTS.set(partName, {
                lineNumbers: [],
                count: 0
            });
        }
        
        const entry = MISSING_PARTS.get(partName);
        if (!entry.lineNumbers.includes(lineNumber)) {
            entry.lineNumbers.push(lineNumber);
        }
        entry.count++;
        
        console.warn(`âš ï¸ Line ${lineNumber}: Missing part "${partName}" (${entry.count} total occurrences)`);
    }
    
    function showGraceReport() {
        if (MISSING_PARTS.size === 0) {
            console.log('ðŸ’š Perfect! No missing parts.');
            closeGracePanel();
            return;
        }
        
        console.log('\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
        console.log('ðŸ’š MACHINE OF LOVING GRACE - Missing Parts Report');
        console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
        console.log(`Scene rendered with ${MISSING_PARTS.size} missing components:\n`);
        
        MISSING_PARTS.forEach((data, partName) => {
            console.log(`  ðŸ“¦ ${partName}`);
            console.log(`     Occurrences: ${data.count}`);
            console.log(`     Lines: ${data.lineNumbers.join(', ')}`);
            console.log(`     ðŸ’¡ Tip: Check if this should be "parts/${partName}"\n`);
        });
        
        console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
        console.log(`âœ… Scene loaded successfully with ${MISSING_PARTS.size} placeholders`);
        console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');
        
        // Show visual error panel with clickable lines
        const panel = document.getElementById('grace-error-panel');
        const list = document.getElementById('grace-error-list');
        
        list.innerHTML = '';
        
        MISSING_PARTS.forEach((data, partName) => {
            data.lineNumbers.forEach(lineNum => {
                const item = document.createElement('div');
                item.className = 'grace-error-item';
                item.innerHTML = `<span class="grace-error-line">Line ${lineNum}:</span> Missing "${partName}" <span style="opacity:0.7">(${data.count}x total)</span>`;
                
                // Click to highlight line in editor
                item.addEventListener('click', () => {
                    highlightErrorLine(lineNum);
                    scrollToLine(lineNum);
                });
                
                list.appendChild(item);
            });
        });
        
        panel.classList.add('visible');
        
        // Highlight all error lines in editor
        highlightAllErrorLines();
    }
    
    function highlightAllErrorLines() {
        // Clear previous error highlights
        document.querySelectorAll('.editor-line.missing-part').forEach(el => {
            el.classList.remove('missing-part');
        });
        
        // Highlight all lines with missing parts
        MISSING_PARTS.forEach((data, partName) => {
            data.lineNumbers.forEach(lineNum => {
                const lineIndex = lineNum - 1; // Convert to 0-based index
                const lineEl = editorContainer.children[lineIndex];
                if (lineEl) {
                    lineEl.classList.add('missing-part');
                }
            });
        });
    }
    
    function highlightErrorLine(lineNum) {
        // Clear previous highlights
        document.querySelectorAll('.editor-line.highlighted').forEach(el => {
            el.classList.remove('highlighted');
        });
        
        const lineIndex = lineNum - 1;
        const lineEl = editorContainer.children[lineIndex];
        if (lineEl) {
            lineEl.classList.add('highlighted');
            lineEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
    }
    
    function scrollToLine(lineNum) {
        const lineIndex = lineNum - 1;
        const lineEl = editorContainer.children[lineIndex];
        if (lineEl) {
            lineEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
    }
    
    function copyGraceErrors() {
        let text = 'ðŸ’š GRACE REPORT - Missing Parts\n';
        text += 'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n';
        
        MISSING_PARTS.forEach((data, partName) => {
            text += `ðŸ“¦ ${partName}\n`;
            text += `   Occurrences: ${data.count}\n`;
            text += `   Lines: ${data.lineNumbers.join(', ')}\n`;
            text += `   ðŸ’¡ Tip: Check if this should be "parts/${partName}"\n\n`;
        });
        
        text += `\nâœ… Scene loaded with ${MISSING_PARTS.size} placeholders\n`;
        
        navigator.clipboard.writeText(text).then(() => {
            const btn = event.target;
            const orig = btn.textContent;
            btn.textContent = 'âœ“ COPIED!';
            setTimeout(() => btn.textContent = orig, 2000);
        });
    }
    
    function closeGracePanel() {
        const panel = document.getElementById('grace-error-panel');
        panel.classList.remove('visible');
    }
    
    // Intercept fetch to catch 404s gracefully
    const originalFetch = window.fetch;
    window.fetch = function(...args) {
        return originalFetch.apply(this, args).then(response => {
            if (!response.ok && response.status === 404) {
                const url = args[0];
                const partName = url.split('/').pop();
                console.warn(`ðŸ’š Grace: 404 for ${partName}, will use placeholder`);
            }
            return response;
        });
    };
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function createScene(name, initialLines = []) {
        return {
            name: name || `Scene ${STATE.scenes.length + 1}`,
            lines: initialLines.length ? initialLines : [
                '0 FILE untitled.mpd',
                '0 Name: untitled',
                '0 Author: ',
                '0 ',
                '0 WRITE YOUR DESCRIPTION HERE',
                '0 ',
                '0 BFC CERTIFY CCW',
                '0 ',
                '0 !CATEGORY ',
                '0 ',
                ''
            ],
            lockedLines: new Set(),
            timestamp: Date.now()
        };
    }
    
    function renderEditor(lines) {
        if (!editorContainer) editorContainer = document.getElementById('mpd-editor');
        if (!editorContainer) return;
        
        editorContainer.innerHTML = '';
        
        lines.forEach((line, idx) => {
            const lineDiv = document.createElement('div');
            lineDiv.className = 'editor-line';
            lineDiv.dataset.lineNum = idx + 1;
            
            const trimmed = line.trim();
            const isComment = trimmed.startsWith('0 ');
            const isPart = trimmed.startsWith('1 ');
            const isFile = trimmed.startsWith('0 FILE');
            const isStep = trimmed.startsWith('0 STEP');
            const scene = STATE.scenes[STATE.activeSceneIdx];
            const isLocked = scene && scene.lockedLines.has(idx);
            
            if (isLocked) lineDiv.classList.add('locked');
            if (isFile) lineDiv.classList.add('file-line');
            if (isStep) lineDiv.classList.add('step-line');
            
            // Checkbox
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.className = 'line-checkbox';
            checkbox.checked = true;
            checkbox.addEventListener('change', () => {
                content.classList.toggle('disabled', !checkbox.checked);
                // Don't auto-compile on checkbox change - use Render button
            });
            lineDiv.appendChild(checkbox);
            
            // Line number
            const lineNum = document.createElement('span');
            lineNum.className = 'line-number';
            lineNum.textContent = idx + 1;
            lineDiv.appendChild(lineNum);
            
            // Right-click context menu
            lineDiv.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                showLineContextMenu(e, idx);
            });
            
            // Click line â†’ highlight on 2D grid
            lineDiv.addEventListener('click', (e) => {
                if (e.target.classList.contains('line-checkbox')) return;
                
                const trimmed = line.trim();
                
                // Cmd/Ctrl+click for multi-selection
                if (e.metaKey || e.ctrlKey) {
                    toggleLineSelection(idx);
                    return;
                }
                
                // If clicking a comment (//), select section
                if (trimmed.startsWith('0 //') || trimmed.startsWith('0 â•â•â•')) {
                    selectSection(idx);
                } else {
                    highlightLineOn2DGrid(idx);
                }
            });
            
            // Double-click line â†’ select section
            lineDiv.addEventListener('dblclick', (e) => {
                if (e.target.classList.contains('line-checkbox')) return;
                selectSection(idx);
            });
            
            // Content (contentEditable!)
            const content = document.createElement('span');
            content.className = `line-content ${isPart ? 'part' : isComment ? 'comment' : ''}`;
            content.textContent = line || ' ';
            content.contentEditable = !isLocked; // Lock mode prevents editing
            content.spellcheck = false;
            
            // Save on blur
            content.addEventListener('blur', () => {
                editorLines[idx] = content.textContent;
            });
            
            // Paste handler - split multiline paste into multiple lines
            content.addEventListener('paste', (e) => {
                e.preventDefault();
                const text = e.clipboardData.getData('text/plain');
                
                // If pasting multiple lines, split them
                const lines = text.split('\n');
                if (lines.length > 1) {
                    // Replace current line with first pasted line
                    editorLines[idx] = lines[0];
                    // Insert remaining lines below
                    editorLines.splice(idx + 1, 0, ...lines.slice(1));
                    renderEditor(editorLines);
                    setTimeout(() => {
                        const newLine = editorContainer.children[idx + lines.length - 1];
                        if (newLine) newLine.querySelector('.line-content').focus();
                    }, 0);
                } else {
                    // Single line paste - just insert at cursor
                    document.execCommand('insertText', false, text);
                }
            });
            
            // Keyboard shortcuts
            content.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    editorLines.splice(idx + 1, 0, '');
                    renderEditor(editorLines);
                    setTimeout(() => {
                        const nextLine = editorContainer.children[idx + 1];
                        if (nextLine) nextLine.querySelector('.line-content').focus();
                    }, 0);
                }
                // Delete/Backspace on empty line = delete line
                else if ((e.key === 'Delete' || e.key === 'Backspace') && !content.textContent.trim()) {
                    e.preventDefault();
                    if (editorLines.length > 1) {
                        deleteLine(idx);
                    }
                }
                // Arrow keys = navigate lines
                else if (e.key === 'ArrowUp' && !e.shiftKey) {
                    const sel = window.getSelection();
                    if (sel.anchorOffset === 0 && idx > 0) {
                        e.preventDefault();
                        const prevLine = editorContainer.children[idx - 1];
                        if (prevLine) prevLine.querySelector('.line-content').focus();
                    }
                }
                else if (e.key === 'ArrowDown' && !e.shiftKey) {
                    const sel = window.getSelection();
                    const atEnd = sel.anchorOffset === content.textContent.length;
                    if (atEnd && idx < editorLines.length - 1) {
                        e.preventDefault();
                        const nextLine = editorContainer.children[idx + 1];
                        if (nextLine) nextLine.querySelector('.line-content').focus();
                    }
                }
                // Ctrl+D = duplicate line
                else if (e.ctrlKey && e.key === 'd') {
                    e.preventDefault();
                    editorLines.splice(idx + 1, 0, editorLines[idx]);
                    renderEditor(editorLines);
                    setTimeout(() => {
                        const newLine = editorContainer.children[idx + 1];
                        if (newLine) newLine.querySelector('.line-content').focus();
                    }, 0);
                }
                // Ctrl+Up/Down = move line
                else if (e.ctrlKey && e.key === 'ArrowUp') {
                    e.preventDefault();
                    moveLine(idx, -1);
                }
                else if (e.ctrlKey && e.key === 'ArrowDown') {
                    e.preventDefault();
                    moveLine(idx, 1);
                }
                // Cmd/Ctrl+S or Cmd/Ctrl+Enter â†’ Compile
                if ((e.metaKey || e.ctrlKey) && (e.key === 's' || e.key === 'S')) {
                    e.preventDefault();
                    compileCurrentMPD();
                }
                if ((e.metaKey || e.ctrlKey) && e.key === 'Enter') {
                    e.preventDefault();
                    compileCurrentMPD();
                }
                // Cmd/Ctrl+C â†’ Copy selection
                if ((e.metaKey || e.ctrlKey) && e.key === 'c' && selectedLines.size > 0) {
                    e.preventDefault();
                    copySelection();
                }
            });
            
            lineDiv.appendChild(content);
            editorContainer.appendChild(lineDiv);
        });
        
        renderMinimap(lines);
    }
    
    function renderMinimap(lines) {
        const minimap = document.getElementById('mpd-minimap');
        if (!minimap) return;
        
        minimap.innerHTML = '';
        const stripHeight = Math.max(2, Math.floor(minimap.clientHeight / lines.length));
        
        lines.forEach((line, idx) => {
            const strip = document.createElement('div');
            strip.className = 'mpd-minimap-strip';
            strip.style.height = stripHeight + 'px';
            
            const trimmed = line.trim();
            if (trimmed.startsWith('1 ')) {
                strip.classList.add('part');
            } else if (trimmed.startsWith('0 ')) {
                strip.classList.add('comment');
            } else {
                strip.classList.add('empty');
            }
            
            const scene = STATE.scenes[STATE.activeSceneIdx];
            if (scene && scene.lockedLines.has(idx)) {
                strip.classList.add('locked');
            }
            
            strip.addEventListener('click', () => {
                const lineEl = editorContainer.children[idx];
                if (lineEl) {
                    lineEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    lineEl.querySelector('.line-content').focus();
                }
            });
            
            minimap.appendChild(strip);
        });
    }
    
    // Line manipulation functions (Bronze parity)
    async function compileCurrentMPD() {
        const scene = STATE.scenes[STATE.activeSceneIdx];
        if (!scene || !scene.lines.length) {
            console.warn('âš ï¸ No MPD lines to compile');
            return;
        }
        await compile();
    }
    
    function deleteLine(idx) {
        const scene = STATE.scenes[STATE.activeSceneIdx];
        if (scene.lockedLines.has(idx)) {
            document.getElementById('status-text').textContent = 'Line is locked';
            return;
        }
        if (editorLines.length === 1) {
            editorLines[0] = '';
            renderEditor(editorLines);
            return;
        }
        editorLines.splice(idx, 1);
        // Update locked lines indices
        const newLocked = new Set();
        scene.lockedLines.forEach(i => {
            if (i < idx) newLocked.add(i);
            else if (i > idx) newLocked.add(i - 1);
        });
        scene.lockedLines = newLocked;
        renderEditor(editorLines);
        document.getElementById('status-text').textContent = 'Line deleted';
    }
    
    function moveLine(idx, direction) {
        const scene = STATE.scenes[STATE.activeSceneIdx];
        if (scene.lockedLines.has(idx)) {
            document.getElementById('status-text').textContent = 'Line is locked';
            return;
        }
        const newIdx = idx + direction;
        if (newIdx < 0 || newIdx >= editorLines.length) return;
        
        // Swap lines
        [editorLines[idx], editorLines[newIdx]] = [editorLines[newIdx], editorLines[idx]];
        
        // Update locked lines
        const wasLocked = scene.lockedLines.has(idx);
        const targetWasLocked = scene.lockedLines.has(newIdx);
        if (wasLocked) {
            scene.lockedLines.delete(idx);
            scene.lockedLines.add(newIdx);
        }
        if (targetWasLocked) {
            scene.lockedLines.delete(newIdx);
            scene.lockedLines.add(idx);
        }
        
        renderEditor(editorLines);
        
        // Scroll to moved line
        setTimeout(() => {
            const movedLine = editorContainer.children[newIdx];
            if (movedLine) {
                movedLine.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                movedLine.querySelector('.line-content').focus();
            }
        }, 50);
        
        document.getElementById('status-text').textContent = direction > 0 ? 'Moved down' : 'Moved up';
    }
    
    function toggleLock(idx) {
        const scene = STATE.scenes[STATE.activeSceneIdx];
        if (scene.lockedLines.has(idx)) {
            scene.lockedLines.delete(idx);
            document.getElementById('status-text').textContent = 'Unlocked';
        } else {
            scene.lockedLines.add(idx);
            document.getElementById('status-text').textContent = 'Locked';
        }
        renderEditor(editorLines);
    }
    
    function showLineContextMenu(e, idx) {
        const scene = STATE.scenes[STATE.activeSceneIdx];
        const isLocked = scene.lockedLines.has(idx);
        
        // Create proper context menu (Bronze style)
        const existingMenu = document.getElementById('line-context-menu');
        if (existingMenu) existingMenu.remove();
        
        const menu = document.createElement('div');
        menu.id = 'line-context-menu';
        menu.style.cssText = `
            position: fixed;
            left: ${e.clientX}px;
            top: ${e.clientY}px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-primary);
            border-radius: 4px;
            padding: 4px;
            z-index: 10000;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
            min-width: 180px;
        `;
        
        const items = [
            { label: `Line ${idx + 1}`, action: null, style: 'font-weight: 700; color: var(--accent); padding: 4px 8px; border-bottom: 1px solid var(--border-primary);' },
            { label: isLocked ? 'ðŸ”“ Unlock' : 'ðŸ”’ Lock', action: () => toggleLock(idx) },
            { label: 'ðŸ“‹ Copy Line', action: () => copyLine(idx) },
            { label: 'âœ‚ï¸ Cut Line', action: () => cutLine(idx) },
            { label: 'ðŸ“ Duplicate', action: () => duplicateLine(idx) },
            { label: 'âž• Insert Above', action: () => insertLine(idx, 'above') },
            { label: 'âž• Insert Below', action: () => insertLine(idx, 'below') },
            { label: '---', action: null },
            { label: 'â†‘ Move Up', action: () => moveLine(idx, -1) },
            { label: 'â†“ Move Down', action: () => moveLine(idx, 1) },
            { label: 'ðŸ—‘ Delete', action: () => deleteLine(idx) },
        ];
        
        items.forEach(item => {
            if (item.label === '---') {
                const divider = document.createElement('div');
                divider.style.cssText = 'height: 1px; background: var(--border-primary); margin: 4px 0;';
                menu.appendChild(divider);
            } else {
                const menuItem = document.createElement('div');
                menuItem.textContent = item.label;
                menuItem.style.cssText = item.style || `
                    padding: 6px 12px;
                    cursor: ${item.action ? 'pointer' : 'default'};
                    color: var(--text-primary);
                    font-size: 12px;
                    transition: background 0.1s;
                `;
                
                if (item.action) {
                    menuItem.addEventListener('mouseenter', () => {
                        menuItem.style.background = 'var(--accent)';
                        menuItem.style.color = '#000';
                    });
                    menuItem.addEventListener('mouseleave', () => {
                        menuItem.style.background = '';
                        menuItem.style.color = 'var(--text-primary)';
                    });
                    menuItem.addEventListener('click', () => {
                        item.action();
                        menu.remove();
                    });
                }
                
                menu.appendChild(menuItem);
            }
        });
        
        document.body.appendChild(menu);
        
        // Close on click outside
        const closeMenu = (e2) => {
            if (!menu.contains(e2.target)) {
                menu.remove();
                document.removeEventListener('click', closeMenu);
            }
        };
        setTimeout(() => document.addEventListener('click', closeMenu), 10);
    }
    
    function copyLine(idx) {
        const line = editorLines[idx];
        navigator.clipboard.writeText(line).then(() => {
            const statusText = document.getElementById('status-text');
            statusText.textContent = 'ðŸ“‹ Copied!';
            statusText.style.color = 'var(--accent)';
            statusText.style.fontWeight = '700';
            setTimeout(() => {
                statusText.textContent = 'Ready';
                statusText.style.color = '';
                statusText.style.fontWeight = '';
            }, 1500);
        }).catch(err => {
            console.error('Copy failed:', err);
            document.getElementById('status-text').textContent = 'Copy failed';
        });
    }
    
    function cutLine(idx) {
        navigator.clipboard.writeText(editorLines[idx]);
        deleteLine(idx);
        document.getElementById('status-text').textContent = 'Line cut';
    }
    
    function duplicateLine(idx) {
        editorLines.splice(idx + 1, 0, editorLines[idx]);
        STATE.scenes[STATE.activeSceneIdx].lines = [...editorLines];
        renderEditor(editorLines);
        document.getElementById('status-text').textContent = 'Line duplicated';
    }
    
    function insertLine(idx, position) {
        const newIdx = position === 'above' ? idx : idx + 1;
        editorLines.splice(newIdx, 0, '');
        STATE.scenes[STATE.activeSceneIdx].lines = [...editorLines];
        renderEditor(editorLines);
        document.getElementById('status-text').textContent = `Line inserted ${position}`;
    }
    
    function highlightErrorLine(lineIdx, errorMsg) {
        console.log('[ERROR HIGHLIGHT] Attempting to highlight line', lineIdx, errorMsg);
        
        // Try multiple selectors
        let lineDiv = document.querySelector(`[data-line-idx="${lineIdx}"]`);
        if (!lineDiv) {
            lineDiv = document.querySelector(`.line-wrapper[data-line-idx="${lineIdx}"]`);
        }
        if (!lineDiv) {
            const allLines = document.querySelectorAll('.line-wrapper');
            if (allLines[lineIdx]) {
                lineDiv = allLines[lineIdx];
            }
        }
        
        if (lineDiv) {
            console.log('[ERROR HIGHLIGHT] Found line element, highlighting...');
            lineDiv.style.background = 'rgba(255, 0, 0, 0.2)';
            lineDiv.style.borderLeft = '3px solid var(--error)';
            lineDiv.style.transition = 'all 0.3s';
            lineDiv.scrollIntoView({ behavior: 'smooth', block: 'center' });
            
            // Add error indicator
            const errorIndicator = document.createElement('span');
            errorIndicator.className = 'error-indicator';
            errorIndicator.textContent = ' âš ï¸';
            errorIndicator.title = errorMsg;
            errorIndicator.style.cssText = 'color: var(--error); font-weight: 700; margin-left: 8px; font-size: 16px;';
            lineDiv.appendChild(errorIndicator);
            
            // Clear after 8 seconds
            setTimeout(() => {
                lineDiv.style.background = '';
                lineDiv.style.borderLeft = '';
                const indicator = lineDiv.querySelector('.error-indicator');
                if (indicator) indicator.remove();
            }, 8000);
        } else {
            console.warn('[ERROR HIGHLIGHT] Could not find line element at index', lineIdx);
        }
    }
    
    function showLoadingOverlay(text = 'Loading...', subtext = 'Please wait...') {
        const loadingEl = document.getElementById('loading');
        const loadingText = loadingEl?.querySelector('.loading-text');
        const loadingSubtext = loadingEl?.querySelector('.loading-subtext');
        
        if (loadingEl) {
            loadingEl.classList.add('active');
            if (loadingText) loadingText.textContent = text;
            if (loadingSubtext) loadingSubtext.textContent = subtext;
            
            // Simulate progress with random MPD line previews
            simulateProgress();
        }
    }
    
    function simulateProgress() {
        const subtext = document.querySelector('.loading-subtext');
        if (!subtext) return;
        
        const steps = [
            'Parsing MPD structure...',
            'Processing part references...',
            'Loading 3D geometry...',
            'Building mesh hierarchy...',
            'Applying materials...',
            'Optimizing scene...',
            'Finalizing render...'
        ];
        
        let step = 0;
        const interval = setInterval(() => {
            if (!document.getElementById('loading').classList.contains('active')) {
                clearInterval(interval);
                return;
            }
            
            if (step < steps.length) {
                subtext.textContent = steps[step];
                step++;
            } else {
                clearInterval(interval);
            }
        }, 400);
    }
    
    function hideLoadingOverlay() {
        const loadingEl = document.getElementById('loading');
        if (loadingEl) loadingEl.classList.remove('active');
    }
    
    async function compile() {
        showLoadingOverlay('Compiling MPD...', 'Parsing lines and preparing 3D model...');
        
        // Safety check: Don't compile if viewer or file map not ready
        if (!STATE.viewer) {
            console.warn('âš ï¸ Viewer not initialized yet');
            hideLoadingOverlay();
            return;
        }
        if (!STATE.libraryFileMap || Object.keys(STATE.libraryFileMap).length === 0) {
            console.warn('âš ï¸ Library catalog not loaded yet - waiting...');
            hideLoadingOverlay();
            const statusText = document.getElementById('status-text');
            if (statusText) statusText.textContent = 'Library loading...';
            return;
        }
        
        // Parse MPD to track line numbers (Bronze method!)
        const lineMap = [];
        editorLines.forEach((line, idx) => {
            const trimmed = line.trim();
            if (trimmed && trimmed.startsWith('1 ')) {
                lineMap.push({ originalLineIdx: idx, lineContent: line });
            }
        });
        STATE.currentLineMap = lineMap;
        console.log('[COMPILE] Tracked', lineMap.length, 'part lines for click-to-highlight');
        
        // Animate compile (FAST - 5ms per line, 300ms duration)
        const lines = editorContainer.querySelectorAll('.editor-line');
        lines.forEach((line, idx) => {
            setTimeout(() => {
                line.classList.add('compiling');
                setTimeout(() => line.classList.remove('compiling'), 300);
            }, idx * 5);  // 5ms per line (was 20ms - 4x faster!)
        });
        
        // Get enabled lines only
        const enabledLines = [];
        editorLines.forEach((line, idx) => {
            const lineEl = editorContainer.children[idx];
            if (lineEl) {
                const checkbox = lineEl.querySelector('.line-checkbox');
                if (checkbox && checkbox.checked) {
                    enabledLines.push(line);
                }
            }
        });
        
        // Render with Prime engine
        const text = enabledLines.join('\n');
        if (text.trim()) {
            console.log('ðŸ“ Compiling', enabledLines.length, 'enabled lines...');
            
            // Clear previous missing parts tracking
            MISSING_PARTS.clear();
            
            await loadManualText(text, {
                filename: STATE.scenes[STATE.activeSceneIdx].name + '.mpd',
                origin: 'Grace Editor'
            });
            
            // Show grace report after load
            setTimeout(() => showGraceReport(), 500);
            
            hideLoadingOverlay();
        } else {
            console.warn('âš ï¸ No enabled lines to compile');
            hideLoadingOverlay();
        }
    }

    async function init() {
        // Initialize first scene
        STATE.scenes.push(createScene('Scene 1'));
        
        // Create Prime Engine
        STATE.viewer = BetaPrimeEngine.create({
            canvas: document.getElementById('viewer'),
            loaderPath: LIBRARY_BASE
        });
        
        attachViewerEvents();
        
        // CRITICAL: Wait for library to load completely before allowing any renders
        await loadLibraryCatalog();
        
        // Wait for viewer to be fully ready
        if (STATE.viewer && STATE.viewer.ready) {
            await STATE.viewer.ready;
        }
        
        setupUI();
        updateSceneSelector();
        
        // Load first scene into editor
        const firstScene = STATE.scenes[0];
        editorLines = [...firstScene.lines];
        renderEditor(editorLines);
        initializeGrids();
        renderSceneDots();
        
        // Log ready state
        graceSystemReady = true;
        console.log('ðŸ’š Grace Editor fully initialized!');
        console.log('  - Machine of Loving Grace: Active');
        console.log('  - Graceful Error Handling: Enabled');
        console.log('  - Prime Engine: Ready');
        console.log('  - Library Catalog:', Object.keys(STATE.libraryFileMap || {}).length, 'variants');
        console.log('  - Line Editor: Ready');
        console.log('  - Scene System: Ready');
        
        const statusText = document.getElementById('status-text');
        if (statusText) statusText.textContent = 'Ready';
        
        // Force initial render to show grid/axes
        if (STATE.viewer && STATE.viewer.render) {
            STATE.viewer.render();
            console.log('[INIT] Initial render complete');
        }
        
        // Setup click-to-highlight (Bronze feature!)
        // Wait a bit for canvas to be created
        setTimeout(() => {
            setupClickToHighlight();
        }, 500);
    }
    
    function setupClickToHighlight() {
        const viewerDiv = document.getElementById('viewer');
        const canvas = viewerDiv.querySelector('canvas');
        if (!canvas) {
            console.warn('[CLICK] Canvas not found yet, will retry');
            return;
        }
        console.log('[CLICK] Click-to-highlight setup complete');
        
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        
        canvas.addEventListener('click', (event) => {
            if (!STATE.viewer || !STATE.viewer.engine) return;
            
            const rect = canvas.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            raycaster.setFromCamera(mouse, STATE.viewer.engine.camera);
            
            // Get all meshes from the model
            const meshes = [];
            if (STATE.viewer.engine.modelWrapper) {
                STATE.viewer.engine.modelWrapper.traverse(obj => {
                    if (obj.isMesh) meshes.push(obj);
                });
            }
            
            const intersects = raycaster.intersectObjects(meshes, false);
            
            if (intersects.length > 0) {
                const clickedObj = intersects[0].object;
                
                // Find line number from userData
                let lineNum = clickedObj.userData?.lineNum;
                if (lineNum === undefined && clickedObj.parent) {
                    lineNum = clickedObj.parent.userData?.lineNum;
                }
                
                if (lineNum !== undefined) {
                    console.log('[CLICK] Part clicked, line:', lineNum);
                    highlightMPDLine(lineNum);
                    
                    // Flash the clicked part
                    const originalColor = clickedObj.material.color.getHex();
                    clickedObj.material.color.setHex(0xffff00); // Yellow flash
                    setTimeout(() => {
                        clickedObj.material.color.setHex(originalColor);
                    }, 300);
                }
            }
        });
    }
    
    function annotateModelWithLineNumbers() {
        if (!STATE.viewer || !STATE.viewer.engine || !STATE.viewer.engine.modelWrapper) {
            console.log('[ANNOTATE] No model to annotate yet');
            return;
        }
        
        if (!STATE.currentLineMap || STATE.currentLineMap.length === 0) {
            console.log('[ANNOTATE] No line map available - will work next compile');
            return;
        }
        
        // Get all meshes from the model
        const meshes = [];
        STATE.viewer.engine.modelWrapper.traverse(obj => {
            if (obj.isMesh) meshes.push(obj);
        });
        
        console.log('[ANNOTATE] Found', meshes.length, 'meshes,', STATE.currentLineMap.length, 'tracked lines');
        
        // Annotate meshes with line numbers (match by order)
        meshes.forEach((mesh, idx) => {
            if (idx < STATE.currentLineMap.length) {
                mesh.userData.lineNum = STATE.currentLineMap[idx].originalLineIdx;
                console.log('[ANNOTATE] Mesh', idx, 'â†’ Line', mesh.userData.lineNum);
            }
        });
        
        console.log('[ANNOTATE] âœ… Model annotated with line numbers');
    }
    
    function highlightMPDLine(lineIdx) {
        // Clear previous highlights
        document.querySelectorAll('.line-wrapper').forEach(el => {
            el.style.background = '';
            el.style.borderLeft = '';
        });
        
        // Highlight the clicked line
        const lineDiv = document.querySelector(`[data-line-idx="${lineIdx}"]`);
        if (lineDiv) {
            lineDiv.style.background = 'rgba(255, 215, 0, 0.3)'; // Gold highlight
            lineDiv.style.borderLeft = '3px solid var(--accent)';
            lineDiv.scrollIntoView({ behavior: 'smooth', block: 'center' });
            
            const statusText = document.getElementById('status-text');
            if (statusText) {
                statusText.textContent = `âœ¨ Line ${lineIdx + 1} selected`;
                setTimeout(() => statusText.textContent = 'Ready', 2000);
            }
            
            console.log('[HIGHLIGHT] MPD line', lineIdx, 'highlighted');
        } else {
            console.warn('[HIGHLIGHT] Could not find line element for index', lineIdx);
        }
    }

    async function loadManifest() {
        try {
            const response = await fetch('./root-models-manifest.json');
            if (!response.ok) throw new Error(`HTTP ${response.status}`);
            const manifest = await response.json();
            WAG.manifest = manifest;
            const files = manifest.files || [];
            const included = [];
            const quarantined = [];
            files.forEach(file => {
                if (!shouldIncludeModel(file)) return;
                if (isQuarantined(file)) {
                    quarantined.push(file);
                } else {
                    included.push(file);
                }
            });
            WAG.models = included.sort((a, b) => (a.filename || '').localeCompare(b.filename || '', undefined, { sensitivity: 'base' }));
            WAG.quarantinedFiles = quarantined;
            WAG.filtered = [...WAG.models];
            updateStats();
            if (!WAG.models.length) {
                document.getElementById('model-list').innerHTML = '<div class="empty-state">No models found. Run <code>node generate-root-models-manifest.js</code>.</div>';
            }
        } catch (err) {
            console.error('Failed to load manifest', err);
            document.getElementById('stats').textContent = 'Manifest missing - run generator script';
            document.getElementById('model-list').innerHTML = '<div class="empty-state">Cannot fetch root-models-manifest.json</div>';
        }
    }

    async function loadLibraryCatalog() {
        const libStatus = document.getElementById('lib-status');
        const loadingEl = document.getElementById('loading');
        const loadingText = loadingEl?.querySelector('.loading-text');
        const loadingSubtext = loadingEl?.querySelector('.loading-subtext');
        
        try {
            libStatus.textContent = 'Library: Loading...';
            
            if (loadingEl) {
                loadingEl.classList.add('active');
                if (loadingText) loadingText.textContent = 'Loading LDraw Library...';
                if (loadingSubtext) loadingSubtext.textContent = 'Fetching part catalog...';
            }
            
            const response = await fetch('./ldraw-parts-manifest.json');
            if (!response.ok) throw new Error(`HTTP ${response.status}`);
            const manifest = await response.json();
            
            if (loadingSubtext) loadingSubtext.textContent = 'Building library index...';
            
            // Process manifest (buildLibraryFileMap is already fast)
            STATE.libraryFileMap = buildLibraryFileMap(manifest);
            
            if (STATE.viewer && STATE.libraryFileMap) {
                STATE.viewer.setFileMap(STATE.libraryFileMap);
            }
            
            const variantCount = Object.keys(STATE.libraryFileMap || {}).length;
            libStatus.textContent = `Library: ${variantCount.toLocaleString()} variants`;
            console.log('âœ“ Library catalog loaded:', variantCount, 'path variants');
            
            if (loadingEl) loadingEl.classList.remove('active');
        } catch (err) {
            console.warn('Unable to preload library manifest', err);
            libStatus.textContent = 'Library: Failed';
            if (loadingEl) loadingEl.classList.remove('active');
        }
    }

    async function loadQuarantineList() {
        try {
            const response = await fetch('./quarantine-section.json');
            if (!response.ok) throw new Error(`HTTP ${response.status}`);
            const data = await response.json();
            const set = new Set();
            (data.files || []).forEach(entry => {
                if (!entry || !entry.filename) return;
                set.add(entry.filename.trim().toLowerCase());
            });
            WAG.quarantineSet = set;
        } catch (err) {
            console.warn('[WAG] Quarantine list missing or invalid; proceeding without exclusions.', err);
            WAG.quarantineSet = new Set();
        }
    }

    function buildLibraryFileMap(manifest) {
        const map = {};
        if (!manifest || !manifest.categories) return map;
        manifest.categories.forEach(category => {
            const basePath = category.path || '';
            (category.files || []).forEach(file => {
                const filename = file.filename || '';
                if (!filename) return;
                const relPathRaw = file.relativePath || file.path || `${basePath}/${filename}`;
                const relPath = normalizeRelativePath(relPathRaw);
                const normalized = normalizeLibraryTarget(relPath);
                registerPathVariants(map, relPath, normalized);
            });
        });
        return map;
    }

    function normalizeRelativePath(path) {
        if (!path) return '';
        return path.replace(/\\/g, '/').replace(/^(\.\/|\.\\)/, '').replace(/^\/+/, '');
    }

    function normalizeLibraryTarget(path) {
        if (!path) return '';
        return path
            .replace(/\\/g, '/')
            .replace(/^(\.\/)+/, '')
            .replace(/^ldraw\//, '')
            .replace(/\/{2,}/g, '/');
    }

    function registerPathVariants(map, relPath, normalizedPath) {
        if (!normalizedPath) return;
        const keys = new Set();
        const clean = relPath;
        const lower = clean.toLowerCase();
        const normalizedLower = normalizedPath.toLowerCase();
        keys.add(clean);
        keys.add(lower);
        keys.add(normalizedPath);
        keys.add(normalizedLower);
        if (clean.startsWith('ldraw/')) {
            const withoutPrefix = clean.replace(/^ldraw\//, '');
            keys.add(withoutPrefix);
            keys.add(withoutPrefix.toLowerCase());
        } else {
            keys.add(`ldraw/${clean}`);
            keys.add(`ldraw/${clean}`.toLowerCase());
        }
        keys.add(`./${clean}`);
        keys.add(`./${clean}`.toLowerCase());
        keys.add(`../${clean}`);
        keys.add(`../${clean}`.toLowerCase());
        if (clean.startsWith('parts/')) {
            const withoutParts = clean.substring(6);
            keys.add(withoutParts);
            keys.add(withoutParts.toLowerCase());
            keys.add(`./${withoutParts}`);
            keys.add(`./${withoutParts}`.toLowerCase());
            keys.add(`../${withoutParts}`);
            keys.add(`../${withoutParts}`.toLowerCase());
            keys.add(`ldraw/${withoutParts}`);
            keys.add(`ldraw/${withoutParts}`.toLowerCase());
        }
        if (clean.startsWith('p/')) {
            const withoutPrimitive = clean.substring(2);
            keys.add(withoutPrimitive);
            keys.add(withoutPrimitive.toLowerCase());
            keys.add(`./${withoutPrimitive}`);
            keys.add(`./${withoutPrimitive}`.toLowerCase());
            keys.add(`../${withoutPrimitive}`);
            keys.add(`../${withoutPrimitive}`.toLowerCase());
            keys.add(`ldraw/${withoutPrimitive}`);
            keys.add(`ldraw/${withoutPrimitive}`.toLowerCase());
        }
        const basename = clean.substring(clean.lastIndexOf('/') + 1);
        keys.add(basename);
        keys.add(basename.toLowerCase());
        keys.forEach(key => {
            if (!key) return;
            const normalizedKey = key.replace(/\\/g, '/').replace(/\/{2,}/g, '/');
            if (normalizedKey && !map[normalizedKey]) {
                map[normalizedKey] = normalizedPath;
            }
        });
    }

    function lookupLibraryPath(rawPath, filename) {
        if (!STATE.libraryFileMap) return null;
        const attempts = [rawPath, rawPath?.toLowerCase(), filename, filename?.toLowerCase()];
        for (const key of attempts) {
            if (key && STATE.libraryFileMap[key]) {
                return STATE.libraryFileMap[key];
            }
        }
        return null;
    }

    function buildCandidatePaths(model) {
        const set = new Set();
        const raw = normalizeRelativePath(model.path || model.filename || '');
        const libraryMatch = lookupLibraryPath(raw, model.filename);
        const add = path => {
            if (!path) return;
            const normalized = normalizeRelativePath(path);
            if (normalized) set.add(normalized);
        };
        const addRoot = path => {
            if (!path) return;
            add(`${ROOT_PREFIX_FROM_LIBRARY}${normalizeRelativePath(path)}`);
        };
        if (libraryMatch) add(libraryMatch);
        add(model.path);
        add(raw);
        if (model.filename) add(model.filename);
        addRoot(model.path);
        addRoot(raw);
        if (model.filename) addRoot(model.filename);
        return Array.from(set).filter(Boolean);
    }

    function shouldIncludeModel(file) {
        const filename = (file.filename || '').trim().toLowerCase();
        const extension = filename.includes('.') ? filename.substring(filename.lastIndexOf('.')) : '';
        if (AI_FILE_PATTERN.test(filename)) return true;
        if (extension === '.mpd') return true;
        const name = (file.name || '').toLowerCase();
        if (name.startsWith('ai ') || name.includes('generated')) return true;
        const description = (file.description || '').toLowerCase();
        return description.includes('ai ') || description.includes('generated');
    }

    function isQuarantined(file) {
        if (!file || !file.filename || !WAG.quarantineSet) return false;
        return WAG.quarantineSet.has(file.filename.trim().toLowerCase());
    }

    function setupUI() {
        window.addEventListener('resize', () => {
            if (STATE.viewer) STATE.viewer.updateRendererSize();
        });
        
        // No redundant controls - WAGY bar handles everything
        
        // New Scene button (footer corner +)
        document.getElementById('new-scene-btn').addEventListener('click', () => {
            const newScene = createScene(`Scene ${STATE.scenes.length + 1}`);
            STATE.scenes.push(newScene);
            switchScene(STATE.scenes.length - 1);
        });
        
        // Help button with fullscreen mode
        document.getElementById('help-btn').addEventListener('click', () => {
            const helpMenu = document.createElement('div');
            helpMenu.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: var(--bg-secondary);
                border: 2px solid var(--accent);
                border-radius: 8px;
                padding: 20px;
                max-width: 400px;
                z-index: 10000;
                box-shadow: 0 8px 32px rgba(0,0,0,0.8);
                color: var(--text-primary);
            `;
            
            helpMenu.innerHTML = `
                <h3 style="color: var(--accent); margin: 0 0 12px 0;">WAG GOLD EDITOR</h3>
                <div style="font-size: 12px; line-height: 1.6; margin-bottom: 16px;">
                    <strong style="color: var(--accent);">EDITING:</strong><br>
                    â˜‘ Checkboxes - Enable/disable parts<br>
                    âŠŸ/âŠž Collapse/expand sections<br>
                    âœŽ Click 3D part to highlight line<br>
                    Right-click - Line actions menu<br>
                    <br>
                    <strong style="color: var(--accent);">KEYBOARD:</strong><br>
                    Ctrl+V - Paste MPD content<br>
                    Ctrl+S - Save | Ctrl+Z - Undo<br>
                    Shift+Click - Multi-select<br>
                    <br>
                    <strong style="color: var(--accent);">PASTE:</strong><br>
                    Copy MPD file contents<br>
                    Paste into editor (Ctrl+V)<br>
                    Hit Reset button to compile<br>
                </div>
                <button id="fullscreen-btn" style="
                    background: var(--accent);
                    color: var(--bg-main);
                    border: none;
                    padding: 8px 16px;
                    border-radius: 4px;
                    cursor: pointer;
                    font-weight: 700;
                    margin-right: 8px;
                ">FULLSCREEN MODE</button>
                <button id="close-help-btn" style="
                    background: var(--bg-main);
                    color: var(--text-primary);
                    border: 1px solid var(--border-primary);
                    padding: 8px 16px;
                    border-radius: 4px;
                    cursor: pointer;
                ">CLOSE</button>
            `;
            
            document.body.appendChild(helpMenu);
            
            // Fullscreen button
            helpMenu.querySelector('#fullscreen-btn').addEventListener('click', () => {
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen().catch(err => {
                        alert('Fullscreen not available: ' + err.message);
                    });
                } else {
                    document.exitFullscreen();
                }
                document.body.removeChild(helpMenu);
            });
            
            // Close button
            helpMenu.querySelector('#close-help-btn').addEventListener('click', () => {
                document.body.removeChild(helpMenu);
            });
            
            // Click outside to close
            setTimeout(() => {
                const closeOnOutside = (e) => {
                    if (!helpMenu.contains(e.target)) {
                        document.body.removeChild(helpMenu);
                        document.removeEventListener('click', closeOnOutside);
                    }
                };
                document.addEventListener('click', closeOnOutside);
            }, 100);
        });
        
        // Mobile paste button - shows paste zone
        document.getElementById('mobile-paste-btn').addEventListener('click', () => {
            showPasteZone();
        });
        
        // Theme toggle button
        document.getElementById('theme-btn').addEventListener('click', () => {
            const root = document.documentElement;
            const btn = document.getElementById('theme-btn');
            const currentTheme = root.getAttribute('data-theme') || 'dark';
            
            const themes = ['dark', 'light', 'green'];
            const icons = { dark: 'ðŸŒ™', light: 'â˜€ï¸', green: 'ðŸŒ¿' };
            const labels = { dark: 'Dark', light: 'Light', green: 'Green' };
            
            const currentIdx = themes.indexOf(currentTheme);
            const nextIdx = (currentIdx + 1) % themes.length;
            const nextTheme = themes[nextIdx];
            
            root.setAttribute('data-theme', nextTheme);
            btn.textContent = icons[nextTheme];
            btn.title = `Theme: ${labels[nextTheme]}`;
            
            const statusText = document.getElementById('status-text');
            if (statusText) statusText.textContent = `Theme: ${labels[nextTheme]}`;
        });
        
        // Background color picker
        const bgColorPicker = document.getElementById('bg-color-picker');
        if (bgColorPicker) {
            bgColorPicker.addEventListener('input', (e) => {
                const color = e.target.value;
                STATE.backgroundColor = color;
                
                // Update Three.js scene background
                if (STATE.viewer && STATE.viewer.engine) {
                    const scene = STATE.viewer.engine.scene;
                    const renderer = STATE.viewer.engine.renderer;
                    
                    if (scene && renderer) {
                        const threeColor = new THREE.Color(color);
                        scene.background = threeColor;
                        renderer.setClearColor(threeColor);
                        
                        console.log('[BG] Updated scene background to', color);
                    }
                }
                
                // Force render using the correct method
                if (STATE.viewer && STATE.viewer.render) {
                    STATE.viewer.render();
                    console.log('[BG] Render triggered');
                }
                
                document.getElementById('status-text').textContent = `Background: ${color}`;
            });
        }
        
        // WAGY bar - complete control center
        const wagyMap = {
            'wire-quick': 'wireframe',
            'axes-quick': 'axes',
            'grid-quick': 'grid',
            'flipy-quick': 'flipY'
        };
        Object.entries(wagyMap).forEach(([btnId, diagKey]) => {
            const btn = document.getElementById(btnId);
            if (btn) {
                setToggleButtonState(btn, !!STATE.diagnostics[diagKey]);
                btn.addEventListener('click', () => {
                    STATE.diagnostics[diagKey] = !STATE.diagnostics[diagKey];
                    setToggleButtonState(btn, STATE.diagnostics[diagKey]);
                    if (STATE.viewer) STATE.viewer.setDiagnostics(STATE.diagnostics);
                });
            }
        });
        
        // Spin button
        const spinBtn = document.getElementById('spin-quick');
        if (spinBtn) {
            setToggleButtonState(spinBtn, STATE.autoSpin);
            spinBtn.addEventListener('click', () => {
                STATE.autoSpin = !STATE.autoSpin;
                setToggleButtonState(spinBtn, STATE.autoSpin);
                if (STATE.viewer) STATE.viewer.setAutoSpin(STATE.autoSpin);
            });
        }
        
        // Reset view button
        const resetBtn = document.getElementById('reset-quick');
        if (resetBtn) {
            resetBtn.addEventListener('click', () => {
                if (STATE.viewer) STATE.viewer.fitToCurrent();
            });
        }
        
        // Import/Export button (footer corner)
        document.getElementById('import-export-btn').addEventListener('click', () => {
            const fileInput = document.createElement('input');
            fileInput.type = 'file';
            fileInput.accept = '.mpd,.ldr,.dat';
            fileInput.addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    const text = await file.text();
                    editorLines = text.split('\n');
                    STATE.scenes[STATE.activeSceneIdx].lines = [...editorLines];
                    STATE.scenes[STATE.activeSceneIdx].name = file.name.replace(/\.(mpd|ldr|dat)$/, '');
                    renderEditor(editorLines);
                    updateSceneSelector();
                    renderSceneDots();
                    document.getElementById('status-text').textContent = `Imported ${file.name}`;
                }
            });
            fileInput.click();
        });
        
        // Minimap toggle
        const minimapToggle = document.getElementById('minimap-toggle');
        const minimap = document.getElementById('minimap');
        if (minimapToggle && minimap) {
            minimapToggle.addEventListener('click', () => {
                const isVisible = minimap.style.display !== 'none';
                minimap.style.display = isVisible ? 'none' : 'block';
                minimapToggle.classList.toggle('active', !isVisible);
            });
        }
        
        // 3D/2D mode toggle
        document.getElementById('mode-3d-tab').addEventListener('click', () => {
            document.getElementById('viewer').style.display = 'block';
            document.getElementById('grid-2d').style.display = 'none';
            document.getElementById('mode-3d-tab').classList.add('active');
            document.getElementById('mode-2d-tab').classList.remove('active');
            
            // Force render after switching back to 3D
            if (STATE.viewer && STATE.viewer.render) {
                setTimeout(() => {
                    STATE.viewer.render();
                    console.log('[3D MODE] Render triggered after display');
                }, 50);
            }
        });
        
        document.getElementById('mode-2d-tab').addEventListener('click', () => {
            const viewer = document.getElementById('viewer');
            const grid2d = document.getElementById('grid-2d');
            const mode3d = document.getElementById('mode-3d-tab');
            const mode2d = document.getElementById('mode-2d-tab');
            
            if (viewer) viewer.style.display = 'none';
            if (grid2d) grid2d.style.display = 'grid';
            if (mode3d) mode3d.classList.remove('active');
            if (mode2d) mode2d.classList.add('active');
            render2DGrid();
        });

        if (STATE.viewer) {
            STATE.viewer.setDiagnostics(STATE.diagnostics);
            STATE.viewer.setAutoSpin(STATE.autoSpin);
        }

        setupPanelButtons();
        setupSceneManagement();
        setupPasteZone();
    }
    
    function setupPasteZone() {
        const pasteZone = document.getElementById('paste-zone');
        const pasteTextarea = document.getElementById('paste-textarea');
        const pasteLoadBtn = document.getElementById('paste-load-btn');
        const pasteCancelBtn = document.getElementById('paste-cancel-btn');
        
        function showPasteZone() {
            pasteZone.classList.add('active');
            pasteTextarea.value = '';
            setTimeout(() => pasteTextarea.focus(), 100);
        }
        
        function hidePasteZone() {
            pasteZone.classList.remove('active');
        }
        
        // Load button - ensure line parsing
        pasteLoadBtn.addEventListener('click', () => {
            const text = pasteTextarea.value;
            if (text) {
                // Split by various line endings (Windows/Unix/Mac)
                const lines = text.split(/\r?\n|\r/);
                editorLines = lines;
                STATE.scenes[STATE.activeSceneIdx].lines = [...editorLines];
                renderEditor(editorLines);
                hidePasteZone();
                const lineCount = lines.length;
                document.getElementById('status-text').textContent = `Loaded ${lineCount} line${lineCount !== 1 ? 's' : ''} from paste`;
                console.log(`[PASTE] Parsed ${lineCount} lines`);
            }
        });
        
        // Cancel button
        pasteCancelBtn.addEventListener('click', hidePasteZone);
        
        // ESC to close
        pasteTextarea.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                hidePasteZone();
            }
        });
        
        // Global paste handler (Ctrl+V anywhere)
        document.addEventListener('paste', (e) => {
            // If pasting in line content, let it handle naturally
            if (e.target.classList.contains('line-content')) return;
            
            // If pasting in paste zone, let it happen
            if (e.target.id === 'paste-textarea') return;
            
            // Otherwise, show paste zone
            e.preventDefault();
            showPasteZone();
            
            // Get clipboard data and put in textarea
            const text = e.clipboardData.getData('text/plain');
            if (text) {
                pasteTextarea.value = text;
            }
        });
        
        // Global keyboard shortcut Ctrl+V
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.key === 'v') {
                // If already focused in line editor, let it handle
                if (e.target.classList.contains('line-content')) return;
                if (e.target.id === 'paste-textarea') return;
                
                // Otherwise show paste zone
                e.preventDefault();
                showPasteZone();
            }
        });
    }
    
    function initializeGrids() {
        // Initialize 2D grid (20x20 with axis labels)
        const grid2d = document.getElementById('grid-2d');
        if (grid2d) {
            grid2d.innerHTML = '';
            grid2d.style.cssText = `
                display: grid;
                grid-template-columns: 40px repeat(20, 1fr);
                grid-template-rows: 40px repeat(20, 1fr);
                gap: 1px;
                background: var(--bg-main);
                width: 100%;
                height: 100%;
            `;
            
            // Top-left corner (empty)
            const corner = document.createElement('div');
            corner.style.cssText = 'background: var(--bg-secondary); border: 1px solid var(--border-primary);';
            grid2d.appendChild(corner);
            
            // Top row X labels (-10 to +9)
            for (let x = -10; x < 10; x++) {
                const label = document.createElement('div');
                label.textContent = x;
                label.style.cssText = `
                    background: var(--bg-secondary);
                    border: 1px solid var(--border-primary);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-size: 10px;
                    color: var(--accent);
                    font-weight: bold;
                `;
                grid2d.appendChild(label);
            }
            
            // Grid rows with Y labels
            for (let y = -10; y < 10; y++) {
                // Y label (left column)
                const label = document.createElement('div');
                label.textContent = -y; // Flip Y for display
                label.style.cssText = `
                    background: var(--bg-secondary);
                    border: 1px solid var(--border-primary);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-size: 10px;
                    color: var(--accent);
                    font-weight: bold;
                `;
                grid2d.appendChild(label);
                
                // Grid cells
                for (let x = -10; x < 10; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'grid-cell';
                    cell.dataset.gridX = x;
                    cell.dataset.gridY = -y;
                    cell.title = `(${x}, ${-y})`;
                    cell.style.cssText = `
                        background: var(--bg-main);
                        border: 1px solid var(--border-primary);
                        cursor: pointer;
                    `;
                    cell.addEventListener('click', () => highlightLinesAtGridPosition(x, -y));
                    grid2d.appendChild(cell);
                }
            }
        }
        
        // Initialize minimap
        const minimapGrid = document.getElementById('minimap-grid');
        if (minimapGrid) {
            minimapGrid.innerHTML = '';
            for (let i = 0; i < 81; i++) {
                const cell = document.createElement('div');
                cell.className = 'minimap-cell';
                minimapGrid.appendChild(cell);
            }
        }
    }
    
    // LDraw color code to CSS color mapping
    function getLDrawColor(colorCode) {
        const colors = {
            '0': '#05131D',      // Black
            '1': '#0055BF',      // Blue
            '2': '#237841',      // Green
            '3': '#008F9B',      // Dark Cyan
            '4': '#C91A09',      // Red
            '5': '#C870A0',      // Pink
            '6': '#583927',      // Brown
            '7': '#9BA19D',      // Light Gray
            '8': '#6D6E5C',      // Dark Gray
            '9': '#B4D2E3',      // Light Blue
            '10': '#4B9F4A',     // Bright Green
            '11': '#55A5AF',     // Cyan
            '12': '#D67240',     // Light Orange
            '13': '#F58624',     // Bright Orange
            '14': '#F3CF50',     // Yellow
            '15': '#FFFFFF',     // White
            '16': '#7BB3D9',     // Default (Main Color)
            '17': '#C2DAB8',     // Trans Green
            '18': '#FCE639',     // Trans Yellow
            '19': '#E4ADC8',     // Trans Pink
            '20': '#C9CAE2',     // Trans Clear
            '21': '#E0C0A0',     // Chrome Gold
            '22': '#81007B',     // Purple
            '23': '#2032B0',     // Dark Blue
            '24': '#FE8E01',     // Trans Orange
            '25': '#D05098',     // Trans Magenta
            '71': '#A0A5A9',     // Light Stone Gray
            '72': '#6C6E68',     // Dark Stone Gray
        };
        
        // Return color or default cyan if not found
        return colors[colorCode] || '#2AC1FF';
    }
    
    function render2DGrid() {
        // Parse ALL editor lines and map to grid with colors
        const occupiedCells = new Map(); // gridX,gridY -> color
        
        console.log('[2D GRID] Rendering from', editorLines.length, 'lines');
        
        editorLines.forEach((line, idx) => {
            const trimmed = line.trim();
            if (!trimmed.startsWith('1 ')) return;
            
            const tokens = trimmed.split(/\s+/);
            if (tokens.length < 15) return;
            
            try {
                const colorCode = tokens[1];
                const x = Math.round(parseFloat(tokens[2]) / 20);
                const z = Math.round(parseFloat(tokens[4]) / 20);
                
                const key = `${x},${z}`;
                if (!occupiedCells.has(key)) {
                    occupiedCells.set(key, { color: colorCode, count: 1 });
                } else {
                    occupiedCells.get(key).count++;
                }
            } catch (e) {
                console.warn('[2D GRID] Parse error on line', idx, e);
            }
        });
        
        console.log('[2D GRID] Occupied cells:', occupiedCells.size);
        
        // Update grid cells
        const cells = document.querySelectorAll('.grid-cell');
        cells.forEach(cell => {
            const x = parseInt(cell.dataset.gridX);
            const y = parseInt(cell.dataset.gridY);
            const key = `${x},${y}`;
            
            if (occupiedCells.has(key)) {
                const data = occupiedCells.get(key);
                const color = getLDrawColor(data.color);
                cell.style.background = color;
                cell.style.border = `1px solid ${color}`;
                cell.classList.add('occupied');
                cell.textContent = data.count > 1 ? data.count : '';
            } else {
                cell.style.background = '';
                cell.style.border = '1px solid var(--border-primary)';
                cell.classList.remove('occupied');
                cell.textContent = '';
            }
        });
        
        // Update minimap with 2D grid data
        render2DMinimap(occupiedCells);
    }
    
    function render2DMinimap(occupiedCells) {
        const minimap = document.getElementById('minimap');
        if (!minimap) return;
        
        // Clear and setup minimap for 2D grid
        minimap.innerHTML = '';
        minimap.style.cssText = `
            position: absolute;
            top: 140px;
            right: 10px;
            width: 120px;
            height: 120px;
            background: rgba(0,0,0,0.9);
            border: 2px solid var(--accent);
            border-radius: 4px;
            display: grid;
            grid-template-columns: repeat(20, 1fr);
            grid-template-rows: repeat(20, 1fr);
            gap: 0;
            padding: 2px;
            z-index: 100;
        `;
        
        // Create 20x20 minimap cells
        for (let y = 10; y >= -9; y--) {
            for (let x = -10; x <= 9; x++) {
                const cell = document.createElement('div');
                const key = `${x},${y}`;
                
                if (occupiedCells.has(key)) {
                    const data = occupiedCells.get(key);
                    const color = getLDrawColor(data.color);
                    cell.style.background = color;
                } else {
                    cell.style.background = 'rgba(42, 193, 255, 0.03)';
                }
                
                cell.style.cssText += `
                    width: 100%;
                    height: 100%;
                `;
                
                minimap.appendChild(cell);
            }
        }
        
        console.log('[2D MINIMAP] Rendered', occupiedCells.size, 'occupied cells');
    }
    
    function highlightLinesAtGridPosition(gridX, gridY) {
        // Find all lines at this grid position
        const matchingIndices = [];
        
        editorLines.forEach((line, idx) => {
            const trimmed = line.trim();
            if (!trimmed.startsWith('1 ')) return;
            
            const tokens = trimmed.split(/\s+/);
            if (tokens.length < 15) return;
            
            try {
                const x = Math.round(parseFloat(tokens[2]) / 20);
                const z = Math.round(parseFloat(tokens[4]) / 20);
                
                if (x === gridX && z === gridY) {
                    matchingIndices.push(idx);
                }
            } catch (e) {
                // Skip invalid lines
            }
        });
        
        if (matchingIndices.length === 0) {
            document.getElementById('status-text').textContent = `No parts at grid (${gridX}, ${gridY})`;
            return;
        }
        
        // Highlight all matching lines in editor
        const editorLines2 = editorContainer.querySelectorAll('.editor-line');
        editorLines2.forEach((lineEl, idx) => {
            if (matchingIndices.includes(idx)) {
                lineEl.classList.add('highlighted');
                setTimeout(() => lineEl.classList.remove('highlighted'), 2000);
            }
        });
        
        // Scroll to first matching line
        const firstLine = editorContainer.children[matchingIndices[0]];
        if (firstLine) {
            firstLine.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
        
        document.getElementById('status-text').textContent = `${matchingIndices.length} part(s) at grid (${gridX}, ${gridY})`;
    }
    
    // Global selection state
    let selectedLines = new Set(); // Multi-selection with Cmd+click
    let selectedSection = { start: -1, end: -1, lines: [] };
    let selectionBoundingBox = null;
    
    function toggleLineSelection(idx) {
        const lineEl = editorContainer.children[idx];
        if (!lineEl) return;
        
        // Toggle selection
        if (selectedLines.has(idx)) {
            selectedLines.delete(idx);
            lineEl.classList.remove('selected');
            console.log(`[DESELECT] Line ${idx + 1}`);
        } else {
            selectedLines.add(idx);
            lineEl.classList.add('selected');
            console.log(`[SELECT] Line ${idx + 1}`);
        }
        
        // Update 2D grid and 3D boxes
        const partIndices = Array.from(selectedLines).filter(i => 
            editorLines[i] && editorLines[i].trim().startsWith('1 ')
        );
        
        // Clear grid selections
        document.querySelectorAll('.grid-cell.selected').forEach(el => el.classList.remove('selected'));
        
        // Highlight on 2D grid
        partIndices.forEach(idx => {
            const trimmed = editorLines[idx].trim();
            const tokens = trimmed.split(/\s+/);
            if (tokens.length >= 15) {
                try {
                    const x = Math.round(parseFloat(tokens[2]) / 20);
                    const z = Math.round(parseFloat(tokens[4]) / 20);
                    
                    const cells = document.querySelectorAll('.grid-cell');
                    cells.forEach(cell => {
                        if (parseInt(cell.dataset.gridX) === x && parseInt(cell.dataset.gridY) === z) {
                            cell.classList.add('selected');
                        }
                    });
                } catch (e) {}
            }
        });
        
        // Draw 3D bounding boxes
        draw3DBoundingBoxes(partIndices);
        
        document.getElementById('status-text').textContent = `Selected: ${selectedLines.size} line(s), ${partIndices.length} part(s)`;
    }
    
    function copySelection() {
        if (selectedLines.size === 0) {
            document.getElementById('status-text').textContent = 'No selection to copy';
            return;
        }
        
        const sortedIndices = Array.from(selectedLines).sort((a, b) => a - b);
        const copiedText = sortedIndices.map(idx => editorLines[idx]).join('\n');
        
        navigator.clipboard.writeText(copiedText).then(() => {
            document.getElementById('status-text').textContent = `âœ“ Copied selection (${selectedLines.size} line${selectedLines.size > 1 ? 's' : ''})`;
            console.log(`[COPY] ${selectedLines.size} lines copied`);
        }).catch(err => {
            document.getElementById('status-text').textContent = `âœ— Copy failed: ${err.message}`;
        });
    }
    
    function selectSection(startIdx) {
        // Clear multi-selection when doing section select
        selectedLines.clear();
        
        // Find section boundaries
        let sectionStart = startIdx;
        let sectionEnd = startIdx;
        
        // Look backwards for previous comment
        for (let i = startIdx - 1; i >= 0; i--) {
            const trimmed = editorLines[i].trim();
            if (trimmed.startsWith('0 //') || trimmed.startsWith('0 â•â•â•')) {
                sectionStart = i;
                break;
            }
            if (trimmed.startsWith('1 ')) {
                sectionStart = i;
            }
        }
        
        // Look forwards to next comment or STEP
        for (let i = startIdx + 1; i < editorLines.length; i++) {
            const trimmed = editorLines[i].trim();
            if (trimmed.startsWith('0 //') || trimmed.startsWith('0 â•â•â•') || 
                trimmed === '0 STEP' || trimmed === '0 NOFILE') {
                sectionEnd = i - 1;
                break;
            }
            if (trimmed.startsWith('1 ')) {
                sectionEnd = i;
            }
        }
        
        // Clear previous selections
        document.querySelectorAll('.editor-line.selected').forEach(el => el.classList.remove('selected'));
        document.querySelectorAll('.grid-cell.selected').forEach(el => el.classList.remove('selected'));
        
        // Highlight selected section
        const partIndices = [];
        for (let i = sectionStart; i <= sectionEnd; i++) {
            const lineEl = editorContainer.children[i];
            if (lineEl) {
                lineEl.classList.add('selected');
                selectedLines.add(i); // Add to multi-selection set
                if (editorLines[i].trim().startsWith('1 ')) {
                    partIndices.push(i);
                }
            }
        }
        
        selectedSection = { start: sectionStart, end: sectionEnd, lines: partIndices };
        
        // Scroll to section start
        const firstLine = editorContainer.children[sectionStart];
        if (firstLine) {
            firstLine.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
        
        // Highlight on 2D grid
        partIndices.forEach(idx => {
            const trimmed = editorLines[idx].trim();
            const tokens = trimmed.split(/\s+/);
            if (tokens.length >= 15) {
                try {
                    const x = Math.round(parseFloat(tokens[2]) / 20);
                    const z = Math.round(parseFloat(tokens[4]) / 20);
                    
                    const cells = document.querySelectorAll('.grid-cell');
                    cells.forEach(cell => {
                        if (parseInt(cell.dataset.gridX) === x && parseInt(cell.dataset.gridY) === z) {
                            cell.classList.add('selected');
                        }
                    });
                } catch (e) {}
            }
        });
        
        // Draw 3D bounding boxes
        draw3DBoundingBoxes(partIndices);
        
        document.getElementById('status-text').textContent = `Selected section: ${partIndices.length} parts (lines ${sectionStart + 1}-${sectionEnd + 1})`;
        console.log(`[SELECT SECTION] Lines ${sectionStart + 1}-${sectionEnd + 1}, ${partIndices.length} parts`);
    }
    
    function draw3DBoundingBoxes(partIndices) {
        if (!STATE.viewer || !STATE.viewer.engine || !STATE.viewer.engine.scene) return;
        
        const scene = STATE.viewer.engine.scene;
        
        // Clear previous bounding boxes
        if (selectionBoundingBox) {
            scene.remove(selectionBoundingBox);
            selectionBoundingBox = null;
        }
        
        // Get meshes for selected parts
        const selectedMeshes = [];
        scene.traverse((obj) => {
            if (obj.userData && obj.userData.lineNum && partIndices.includes(obj.userData.lineNum)) {
                selectedMeshes.push(obj);
            }
        });
        
        if (selectedMeshes.length === 0) {
            console.log('[BOUNDING BOX] No meshes found for selected parts');
            return;
        }
        
        console.log(`[BOUNDING BOX] Drawing boxes for ${selectedMeshes.length} meshes`);
        
        // Create bounding box group
        const boxGroup = new THREE.Group();
        boxGroup.name = 'selection-bounding-boxes';
        
        selectedMeshes.forEach((mesh, idx) => {
            // Create edges geometry for wireframe effect
            const edges = new THREE.EdgesGeometry(mesh.geometry);
            const lineMaterial = new THREE.LineBasicMaterial({ 
                color: 0x00ff00, 
                linewidth: 2,
                transparent: true,
                opacity: 0.8
            });
            const wireframe = new THREE.LineSegments(edges, lineMaterial);
            
            // Copy mesh transform to wireframe
            wireframe.position.copy(mesh.position);
            wireframe.rotation.copy(mesh.rotation);
            wireframe.scale.copy(mesh.scale);
            
            // Apply parent transforms if needed
            if (mesh.parent) {
                wireframe.applyMatrix4(mesh.parent.matrixWorld);
            }
            
            boxGroup.add(wireframe);
        });
        
        selectionBoundingBox = boxGroup;
        scene.add(boxGroup);
        
        // Force render
        if (STATE.viewer.engine.render) {
            STATE.viewer.engine.render();
        }
    }
    
    function highlightLineOn2DGrid(lineIdx) {
        const line = editorLines[lineIdx];
        if (!line) return;
        
        const trimmed = line.trim();
        
        // Clear previous selections
        selectedLines.clear();
        document.querySelectorAll('.editor-line.selected').forEach(el => el.classList.remove('selected'));
        document.querySelectorAll('.grid-cell.selected').forEach(el => el.classList.remove('selected'));
        
        // Clear bounding boxes
        if (selectionBoundingBox && STATE.viewer && STATE.viewer.engine) {
            STATE.viewer.engine.scene.remove(selectionBoundingBox);
            selectionBoundingBox = null;
            if (STATE.viewer.engine.render) STATE.viewer.engine.render();
        }
        
        // Add single line to selection
        selectedLines.add(lineIdx);
        
        // Highlight selected line in editor
        const lineEl = editorContainer.children[lineIdx];
        if (lineEl) {
            lineEl.classList.add('selected');
            lineEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
        
        // If it's a Type 1 line, highlight on 2D grid
        if (!trimmed.startsWith('1 ')) {
            document.getElementById('status-text').textContent = `Selected: ${trimmed.substring(0, 50)}...`;
            return;
        }
        
        const tokens = trimmed.split(/\s+/);
        if (tokens.length < 15) return;
        
        try {
            const color = parseInt(tokens[1]);
            const x = Math.round(parseFloat(tokens[2]) / 20);
            const z = Math.round(parseFloat(tokens[4]) / 20);
            
            // Find and highlight grid cell
            const cells = document.querySelectorAll('.grid-cell');
            cells.forEach(cell => {
                const cellX = parseInt(cell.dataset.gridX);
                const cellY = parseInt(cell.dataset.gridY);
                
                if (cellX === x && cellY === z) {
                    cell.classList.add('selected');
                }
            });
            
            // Update status
            const partName = tokens[tokens.length - 1];
            document.getElementById('status-text').textContent = `Selected: ${partName} at (${x}, ${z}) - Line ${lineIdx + 1}`;
            
            console.log(`[SELECT] Line ${lineIdx + 1} â†’ Grid (${x}, ${z})`);
        } catch (e) {
            console.warn('[SELECT] Invalid line format:', e.message);
        }
    }
    
    function highlightMissingParts(missing404Parts) {
        // Highlight lines that reference missing parts
        editorLines.forEach((line, idx) => {
            const trimmed = line.trim();
            if (!trimmed.startsWith('1 ')) return;
            
            const tokens = trimmed.split(/\s+/);
            if (tokens.length < 15) return;
            
            const partName = tokens[tokens.length - 1];
            
            // Check if this part is in the 404 list
            for (const missingPart of missing404Parts) {
                if (missingPart.includes(partName) || partName.includes(missingPart.replace(/^.*\//, ''))) {
                    const lineEl = editorContainer.children[idx];
                    if (lineEl) {
                        lineEl.classList.add('missing-part');
                        lineEl.title = `Missing part: ${missingPart}`;
                    }
                    break;
                }
            }
        });
        
        document.getElementById('status-text').textContent = `âš  ${missing404Parts.size} missing part(s) - check red lines`;
    }
    
    function renderSceneDots() {
        const dotsContainer = document.getElementById('scene-dots-vertical');
        if (!dotsContainer) return;
        
        dotsContainer.innerHTML = '';
        
        STATE.scenes.forEach((scene, idx) => {
            const dot = document.createElement('div');
            dot.style.cssText = `
                width: 14px;
                height: 14px;
                border-radius: 50%;
                background: ${idx === STATE.activeSceneIdx ? 'var(--accent)' : 'rgba(255,255,255,0.3)'};
                border: 2px solid ${idx === STATE.activeSceneIdx ? 'var(--accent)' : 'rgba(255,255,255,0.5)'};
                cursor: pointer;
                transition: all 0.2s;
            `;
            dot.title = scene.name;
            dot.addEventListener('click', () => switchScene(idx));
            dot.addEventListener('mouseenter', () => {
                if (idx !== STATE.activeSceneIdx) {
                    dot.style.background = 'rgba(255,215,0,0.5)';
                }
            });
            dot.addEventListener('mouseleave', () => {
                if (idx !== STATE.activeSceneIdx) {
                    dot.style.background = 'rgba(255,255,255,0.3)';
                }
            });
            dotsContainer.appendChild(dot);
        });
        
        // Add divider
        const divider = document.createElement('div');
        divider.style.cssText = `
            width: 20px;
            height: 1px;
            background: var(--border-primary);
        `;
        dotsContainer.appendChild(divider);
        
        // Add new scene button
        const newBtn = document.createElement('div');
        newBtn.textContent = '+';
        newBtn.style.cssText = `
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: rgba(255,255,255,0.2);
            border: 1px solid rgba(255,255,255,0.5);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            color: var(--text-primary);
            transition: all 0.2s;
        `;
        newBtn.title = 'New Scene (Session)';
        newBtn.addEventListener('click', () => {
            const newScene = createScene(`Scene ${STATE.scenes.length + 1}`);
            STATE.scenes.push(newScene);
            switchScene(STATE.scenes.length - 1);
        });
        newBtn.addEventListener('mouseenter', () => {
            newBtn.style.background = 'var(--accent)';
            newBtn.style.borderColor = 'var(--accent)';
        });
        newBtn.addEventListener('mouseleave', () => {
            newBtn.style.background = 'rgba(255,255,255,0.2)';
            newBtn.style.borderColor = 'rgba(255,255,255,0.5)';
        });
        dotsContainer.appendChild(newBtn);
    }

    function setupPanelButtons() {
        // Render button (âŸ³ Force Render)
        document.getElementById('render-btn').addEventListener('click', () => {
            const statusText = document.getElementById('status-text');
            if (statusText) statusText.textContent = 'Rendering...';
            
            // Small delay to show status
            setTimeout(() => {
                compile();
            }, 100);
        });
        
        // Copy All button
        document.getElementById('copy-all-btn').addEventListener('click', () => {
            const text = editorLines.join('\n');
            navigator.clipboard.writeText(text).then(() => {
                const statusText = document.getElementById('status-text');
                statusText.textContent = `ðŸ“‹ Copied ${editorLines.length} lines!`;
                statusText.style.color = 'var(--accent)';
                statusText.style.fontWeight = '700';
                setTimeout(() => {
                    statusText.textContent = 'Ready';
                    statusText.style.color = '';
                    statusText.style.fontWeight = '';
                }, 2000);
            });
        });
        
        // New MPD - Create blank template
        document.getElementById('new-mpd-btn').addEventListener('click', () => {
            if (confirm('Create new blank MPD? Current scene will be saved.')) {
                editorLines = [
                    '0 FILE untitled.mpd',
                    '0 Name: New Model',
                    '0 Author: ',
                    '0 ',
                    '0 ',
                ];
                STATE.scenes[STATE.activeSceneIdx].lines = [...editorLines];
                renderEditor(editorLines);
                document.getElementById('status-text').textContent = 'New blank MPD created';
            }
        });
        
        // Discard (Clear but keep locked)
        document.getElementById('clear-mpd-btn').addEventListener('click', () => {
            if (confirm('Discard unlocked lines? Locked lines will be kept.')) {
                const scene = STATE.scenes[STATE.activeSceneIdx];
                const newLines = [];
                editorLines.forEach((line, idx) => {
                    if (scene.lockedLines.has(idx)) {
                        newLines.push(line);
                    }
                });
                if (newLines.length === 0) {
                    newLines.push('0 FILE scene.mpd', '0 Empty', '', '0 STEP', '0 NOFILE');
                }
                editorLines = newLines;
                renderEditor(editorLines);
                document.getElementById('status-text').textContent = 'Unlocked lines discarded';
            }
        });
        
        // Undo/Redo with simple history
        const history = {
            stack: [],
            position: -1,
            maxSize: 50
        };
        
        function saveHistory() {
            // Remove any redo history
            history.stack = history.stack.slice(0, history.position + 1);
            // Add current state
            history.stack.push([...editorLines]);
            // Limit size
            if (history.stack.length > history.maxSize) {
                history.stack.shift();
            } else {
                history.position++;
            }
        }
        
        // Save initial state
        saveHistory();
        
        // Undo
        document.getElementById('mpd-undo-btn').addEventListener('click', () => {
            if (history.position > 0) {
                history.position--;
                editorLines = [...history.stack[history.position]];
                STATE.scenes[STATE.activeSceneIdx].lines = [...editorLines];
                renderEditor(editorLines);
                document.getElementById('status-text').textContent = `Undo (${history.position + 1}/${history.stack.length})`;
            } else {
                document.getElementById('status-text').textContent = 'Nothing to undo';
            }
        });
        
        // Redo
        document.getElementById('mpd-redo-btn').addEventListener('click', () => {
            if (history.position < history.stack.length - 1) {
                history.position++;
                editorLines = [...history.stack[history.position]];
                STATE.scenes[STATE.activeSceneIdx].lines = [...editorLines];
                renderEditor(editorLines);
                document.getElementById('status-text').textContent = `Redo (${history.position + 1}/${history.stack.length})`;
            } else {
                document.getElementById('status-text').textContent = 'Nothing to redo';
            }
        });
        
        // Hook into renderEditor to save history after major changes
        const originalRenderEditor = renderEditor;
        renderEditor = function(lines) {
            originalRenderEditor.call(this, lines);
            // Auto-save after render (debounced)
            clearTimeout(renderEditor.saveTimer);
            renderEditor.saveTimer = setTimeout(() => saveHistory(), 500);
        };
        
        // Screenshot button
        document.getElementById('screenshot-btn').addEventListener('click', () => {
            captureScreenshot();
        });
        
        // Global keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            // Delete key = Delete selected lines (GRACE FEATURE!)
            if (e.key === 'Delete' || e.key === 'Backspace') {
                // Only if not focused in editable content
                if (e.target.classList.contains('line-content')) return;
                
                if (selectedLines.size > 0) {
                    e.preventDefault();
                    
                    // Sort in reverse order so deletion doesn't shift indices
                    const sortedIndices = Array.from(selectedLines).sort((a, b) => b - a);
                    
                    // Delete lines from bottom up
                    sortedIndices.forEach(idx => {
                        editorLines.splice(idx, 1);
                    });
                    
                    // Clear selection
                    selectedLines.clear();
                    
                    // Re-render editor
                    renderEditor(editorLines);
                    
                    const statusText = document.getElementById('status-text');
                    if (statusText) {
                        statusText.textContent = `ðŸ’š Deleted ${sortedIndices.length} line(s)`;
                        statusText.style.color = 'var(--success)';
                        setTimeout(() => {
                            statusText.textContent = 'Ready';
                            statusText.style.color = '';
                        }, 2000);
                    }
                    
                    console.log(`ðŸ’š Grace: Deleted ${sortedIndices.length} selected lines`);
                    return;
                }
            }
            
            // Ctrl+Shift+S = Screenshot
            if (e.ctrlKey && e.shiftKey && e.key === 'S') {
                e.preventDefault();
                captureScreenshot();
                return;
            }
            
            // Cmd+S or Ctrl+S = Trigger render (compile)
            if ((e.metaKey || e.ctrlKey) && e.key === 's') {
                e.preventDefault();
                compile();
                return;
            }
        });
    }
    
    function captureScreenshot() {
        const statusText = document.getElementById('status-text');
        if (statusText) statusText.textContent = 'Capturing 4:3 shot...';
        
        try {
            // Get canvas from Prime engine viewer
            const canvas = document.querySelector('#viewer canvas');
            if (!canvas) {
                if (statusText) statusText.textContent = 'No canvas found';
                logError('Screenshot', new Error('Canvas element not found'));
                return;
            }
            
            // Force multiple render frames to ensure scene is drawn
            if (STATE.viewer && STATE.viewer.render) {
                STATE.viewer.render();
                STATE.viewer.render();
                STATE.viewer.render();
            }
            
            // Small delay to let rendering complete
            setTimeout(() => {
                captureScreenshotDelayed(canvas, statusText);
            }, 100);
        } catch (err) {
            console.error('Screenshot failed:', err);
            logError('Screenshot', err);
            if (statusText) statusText.textContent = 'Screenshot failed';
        }
    }
    
    function captureScreenshotDelayed(canvas, statusText) {
        try {
            // CRITICAL: Resize renderer to 4:3 BEFORE capturing (no stretching!)
            const targetWidth = 1600;
            const targetHeight = 1200; // 4:3 ratio
            let dataURL = null;
            
            if (STATE.viewer && STATE.viewer.renderer) {
                const renderer = STATE.viewer.renderer;
                const camera = STATE.viewer.camera;
                const scene = STATE.viewer.scene;
                
                console.log('[SCREENSHOT] Renderer:', renderer);
                console.log('[SCREENSHOT] Camera:', camera);
                console.log('[SCREENSHOT] Scene:', scene);
                
                // Store original size
                const origWidth = renderer.domElement.width;
                const origHeight = renderer.domElement.height;
                
                console.log('[SCREENSHOT] Original:', origWidth, 'x', origHeight);
                console.log('[SCREENSHOT] Resizing to native 4:3:', targetWidth, 'x', targetHeight);
                
                // Resize renderer to 4:3 aspect ratio
                renderer.setSize(targetWidth, targetHeight, false);
                camera.aspect = targetWidth / targetHeight;
                camera.updateProjectionMatrix();
                
                // Render at new 4:3 size - use the engine's render directly
                console.log('[SCREENSHOT] About to render...');
                renderer.render(scene, camera);
                console.log('[SCREENSHOT] Render complete');
                
                // Capture at NATIVE 4:3 resolution (no stretching!)
                console.log('[SCREENSHOT] Calling toDataURL...');
                dataURL = renderer.domElement.toDataURL('image/png');
                console.log('[SCREENSHOT] dataURL length:', dataURL ? dataURL.length : 'NULL');
                
                // Restore original size
                renderer.setSize(origWidth, origHeight, false);
                camera.aspect = origWidth / origHeight;
                camera.updateProjectionMatrix();
                renderer.render(scene, camera);
                
                console.log('[SCREENSHOT] âœ… Captured at native 4:3, restored to', origWidth, 'x', origHeight);
            }
            
            if (!dataURL) {
                throw new Error('Failed to capture screenshot - no dataURL generated');
            }
            
            // Create filename with date and scene name
            const scene = STATE.scenes[STATE.activeSceneIdx];
            const filename = scene.name.replace(/[^a-z0-9]/gi, '_').toLowerCase();
            const date = new Date();
            const dateStr = date.toISOString().split('T')[0];
            const timeStr = date.toTimeString().split(' ')[0].replace(/:/g, '-');
            
            const baseFilename = `wag_gold_${filename}_${dateStr}_${timeStr}`;
            
            // Create JSON metadata
            const metadata = {
                filename: `${baseFilename}.png`,
                scene: scene.name,
                date: dateStr,
                time: timeStr,
                timestamp: date.toISOString(),
                aspect_ratio: '4:3',
                resolution: `${targetWidth}x${targetHeight}`,
                line_count: editorLines.length,
                locked_lines: Array.from(scene.lockedLines),
                theme: document.documentElement.getAttribute('data-theme') || 'dark',
                diagnostics: STATE.diagnostics,
                camera: STATE.viewer.getCamera ? STATE.viewer.getCamera() : null,
                errors: ERROR_LOG.length,
                mpd_content: editorLines.join('\n')
            };
            
            // Download PNG
            const imgLink = document.createElement('a');
            imgLink.href = dataURL;
            imgLink.download = `${baseFilename}.png`;
            imgLink.click();
            
            // Download JSON
            const jsonBlob = new Blob([JSON.stringify(metadata, null, 2)], { type: 'application/json' });
            const jsonURL = URL.createObjectURL(jsonBlob);
            const jsonLink = document.createElement('a');
            jsonLink.href = jsonURL;
            jsonLink.download = `${baseFilename}.json`;
            jsonLink.click();
            URL.revokeObjectURL(jsonURL);
            
            if (statusText) {
                statusText.textContent = 'ðŸ“¸ Screenshot + JSON saved!';
                setTimeout(() => statusText.textContent = 'Ready', 2000);
            }
        } catch (err) {
            console.error('Screenshot delayed failed:', err);
            logError('Screenshot', err);
            if (statusText) statusText.textContent = 'Screenshot failed';
        }
    }
    
    function updateSceneSelector() {
        const selector = document.getElementById('scene-selector');
        const fileName = document.getElementById('file-name');
        
        if (!selector) return;
        
        // Rebuild options
        selector.innerHTML = '';
        STATE.scenes.forEach((scene, idx) => {
            const option = document.createElement('option');
            option.value = idx;
            option.textContent = `${scene.name} (${scene.lines.length}L)`;
            if (idx === STATE.activeSceneIdx) option.selected = true;
            selector.appendChild(option);
        });
        
        // Update file name in header
        if (fileName) {
            fileName.textContent = STATE.scenes[STATE.activeSceneIdx].name;
        }
    }
    
    function switchScene(idx) {
        idx = parseInt(idx);
        if (idx === STATE.activeSceneIdx) return;
        
        // Save current scene (get current lines from editor)
        STATE.scenes[STATE.activeSceneIdx].lines = [...editorLines];
        
        // Load new scene
        STATE.activeSceneIdx = idx;
        const scene = STATE.scenes[idx];
        editorLines = [...scene.lines];
        renderEditor(editorLines);
        
        // Update UI
        updateSceneSelector();
        renderSceneDots();
        document.getElementById('status-text').textContent = `Switched to ${scene.name}`;
    }
    
    function closeScene(idx) {
        if (STATE.scenes.length === 1) {
            document.getElementById('status-text').textContent = 'Cannot close last scene';
            return;
        }
        
        STATE.scenes.splice(idx, 1);
        if (STATE.activeSceneIdx >= STATE.scenes.length) {
            STATE.activeSceneIdx = STATE.scenes.length - 1;
        }
        if (idx <= STATE.activeSceneIdx && STATE.activeSceneIdx > 0) {
            STATE.activeSceneIdx--;
        }
        
        switchScene(STATE.activeSceneIdx);
    }
    
    function setupSceneManagement() {
        const selector = document.getElementById('scene-selector');
        
        // Scene selector change
        selector.addEventListener('change', (e) => {
            switchScene(e.target.value);
        });
        
        // Right-click on selector for context menu (new/delete)
        selector.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            showSceneContextMenu(e.clientX, e.clientY);
        });
    }
    
    function showSceneContextMenu(x, y) {
        // Simple prompt-based for now
        const action = prompt('Scene Actions:\n1. New Scene\n2. Rename Scene\n3. Delete Scene (if >1)\n\nEnter 1, 2, or 3:');
        
        if (action === '1') {
            const newScene = createScene(`Scene ${STATE.scenes.length + 1}`);
            STATE.scenes.push(newScene);
            switchScene(STATE.scenes.length - 1);
        } else if (action === '2') {
            const newName = prompt('New scene name:', STATE.scenes[STATE.activeSceneIdx].name);
            if (newName && newName.trim()) {
                STATE.scenes[STATE.activeSceneIdx].name = newName.trim();
                updateSceneSelector();
            }
        } else if (action === '3' && STATE.scenes.length > 1) {
            closeScene(STATE.activeSceneIdx);
        }
    }


    function attachViewerEvents() {
        if (!STATE.viewer) return;
        const loading = document.getElementById('loading');
        const statusText = document.getElementById('status-text');
        const modelStats = document.getElementById('model-stats');
        
        STATE.viewer.on('model:loaded', ({ meta, stats }) => {
            loading.classList.remove('active');
            const sourceLabel = meta?.origin || 'Catalog';
            const resolvedPath = meta?.source || meta?.resolvedPath || meta?.path || meta?.filename;
            updateInfo(meta, resolvedPath, stats, sourceLabel);
            
            // Update footer
            statusText.textContent = 'Model loaded';
            statusText.style.color = 'var(--success)';
            modelStats.textContent = `${stats.meshes || 0} meshes â€¢ ${(stats.triangles || 0).toLocaleString()} tris`;
            setTimeout(() => {
                statusText.textContent = 'Ready';
                statusText.style.color = 'var(--accent)';
            }, 3000);
        });
        
        STATE.viewer.on('model:cleared', () => {
            loading.classList.remove('active');
            modelStats.textContent = 'No model loaded';
        });
    }

    function filterModels(query) {
        const q = query.trim().toLowerCase();
        if (!q) {
            WAG.filtered = [...WAG.models];
        } else {
            WAG.filtered = WAG.models.filter(model => {
                const hay = `${model.filename} ${model.name || ''} ${model.description || ''}`.toLowerCase();
                return hay.includes(q);
            });
        }
        renderModelList();
        updateStats(q);
    }

    function renderModelList() {
        const list = document.getElementById('model-list');
        list.innerHTML = '';
        if (!WAG.filtered.length) {
            list.innerHTML = '<div class="empty-state">No models match.</div>';
            return;
        }
        WAG.filtered.forEach((model, idx) => {
            const item = document.createElement('div');
            item.className = 'model-item';
            if (idx === WAG.lastSelectedIdx) item.classList.add('active');
            item.innerHTML = `<div class="model-title">${model.name || model.filename}</div>
                              <div class="model-meta">${model.filename} â€¢ ${formatBytes(model.size)}</div>`;
            item.addEventListener('click', () => {
                document.querySelectorAll('.model-item').forEach(el => el.classList.remove('active'));
                item.classList.add('active');
                WAG.lastSelectedIdx = idx;
                loadModel(model);
            });
            list.appendChild(item);
        });
    }

    async function loadModel(model) {
        if (!WAG.viewer) return;
        const loading = document.getElementById('loading');
        loading.classList.add('active');
        const logLabel = `[WAG] ${model.filename}`;
        console.groupCollapsed(`${logLabel} â€“ load start`);
        try {
            const candidatePaths = buildCandidatePaths(model);
            console.log('Candidate paths:', candidatePaths);
            const resolvedPath = await loadWithFallbacks(candidatePaths, {
                filename: model.filename,
                name: model.name,
                author: model.author,
                size: model.size,
                description: model.description,
                origin: 'Catalog'
            });
            console.log('Loaded via:', resolvedPath);
            
            // GOLD EDITOR: Also load text into line editor
            try {
                const response = await fetch(encodeURI(resolvedPath));
                if (response.ok) {
                    const text = await response.text();
                    editorLines = text.split('\n');
                    renderEditor(editorLines);
                    console.log('âœ“ Loaded into line editor');
                }
            } catch (err) {
                console.warn('Could not load text into editor:', err);
            }
        } catch (err) {
            console.error(`${logLabel} â€“ failed after fallback attempts`, err);
            alert(`Failed to load ${model.filename}: ${err.message}`);
            loading.classList.remove('active');
        } finally {
            console.groupEnd();
        }
    }

    async function loadWithFallbacks(paths, meta) {
        if (!WAG.viewer) throw new Error('Viewer not initialized');
        let lastError = null;
        for (const candidate of paths) {
            const encoded = encodeURI(candidate);
            try {
                await WAG.viewer.loadPath(encoded, { ...meta, resolvedPath: candidate });
                return candidate;
            } catch (err) {
                console.warn('[WAG] Path failed', candidate, err);
                lastError = err;
            }
        }
        throw lastError || new Error('All path fallbacks failed');
    }

    async function loadManualText(rawText, meta = {}) {
        if (!STATE.viewer) return;
        
        showLoadingOverlay('Loading Model...', 'Building 3D geometry...');
        
        // Filter out ONLY pure decoration lines (box drawing ONLY, no text)
        const cleanedLines = (rawText || '').split('\n').filter(line => {
            const trimmed = line.trim();
            
            // Keep empty lines
            if (trimmed === '') return true;
            
            // Keep ALL Type 1-5 lines (parts, lines, triangles, quads, optional)
            if (/^[1-5]\s/.test(trimmed)) return true;
            
            // For Type 0 (comments), only filter PURE decoration (box chars with no words)
            if (trimmed.startsWith('0 ') || trimmed.startsWith('0\t')) {
                // Keep if it has important keywords
                if (/\b(FILE|NOFILE|STEP|BFC|AUTHOR|NAME|!LDRAW|CERTIFY|CCW|CW)\b/i.test(trimmed)) {
                    return true;
                }
                // Remove ONLY if it's pure box-drawing decoration
                if (/^0\s+[â•â•”â•—â•šâ•â•‘â”ƒâ”â”“â”—â”›â”â”‚â”œâ”¤â”¬â”´â”¼â•¬â• â•£â•¦â•©â”€â–‘â–’â–“]{3,}\s*$/.test(trimmed)) {
                    return false;
                }
                // Keep all other comments (they might be important)
                return true;
            }
            
            // Keep everything else
            return true;
        });
        
        console.log('[LOAD] Original lines:', (rawText || '').split('\n').length, 'â†’ Cleaned:', cleanedLines.length);
        
        const text = cleanedLines.join('\n').trim();
        if (!text) {
            alert('Paste MPD/LDR contents first.');
            return;
        }
        const loading = document.getElementById('loading');
        loading.classList.add('active');
        try {
            const result = await STATE.viewer.loadText(text, { ...meta });
            console.log('[WAG] Load result:', result);
            
            // CRITICAL: Fit camera to model after loading
            if (STATE.viewer && STATE.viewer.fitToCurrent) {
                STATE.viewer.fitToCurrent();
                console.log('[WAG] Camera fitted to model');
            }
            
            // Annotate meshes with line numbers (Bronze method!)
            annotateModelWithLineNumbers();
            
            clearModelSelection();
            loading.classList.remove('active');
            hideLoadingOverlay();
        } catch (err) {
            hideLoadingOverlay();
            console.error('[WAG] Manual text load failed', err);
            logError('Manual Load', err);
            
            // Check if model is empty (all lines filtered out)
            if (err.message && err.message.includes('empty')) {
                alert('âš ï¸ Model appears empty!\n\nThis might be because:\nâ€¢ All lines were decoration/comments\nâ€¢ No actual part geometry (Type 1 lines)\nâ€¢ File contains only metadata\n\nTry adding some parts like:\n1 4 0 0 0 1 0 0 0 1 0 0 0 1 3001.dat');
            }
            
            // Try to find offending line from error message
            if (err.message) {
                const lineMatch = err.message.match(/line\s+(\d+)/i);
                if (lineMatch) {
                    const lineNum = parseInt(lineMatch[1]) - 1;
                    console.log('[ERROR] Highlighting line from error:', lineNum);
                    setTimeout(() => highlightErrorLine(lineNum, err.message), 200);
                }
            }
            
            // Also try stack trace for line numbers
            if (err.stack) {
                const stackLineMatch = err.stack.match(/:(\d+):/);
                if (stackLineMatch && !lineMatch) {
                    const lineNum = parseInt(stackLineMatch[1]);
                    console.log('[ERROR] Highlighting line from stack:', lineNum);
                    setTimeout(() => highlightErrorLine(lineNum, err.message), 200);
                }
            }
            
            alert(`Manual scene load failed: ${err.message}`);
            loading.classList.remove('active');
        }
    }

    async function loadManualPath(rawPath) {
        if (!WAG.viewer) return;
        const path = (rawPath || '').trim();
        if (!path) {
            alert('Provide a relative path (e.g. scene-the-grinning-default.mpd).');
            return;
        }
        const loading = document.getElementById('loading');
        loading.classList.add('active');
        try {
            await WAG.viewer.loadPath(path, {
                filename: path,
                name: path,
                description: 'Loaded via manual path',
                origin: 'Manual Path'
            });
            clearModelSelection();
        } catch (err) {
            console.error('[WAG] Manual path load failed', err);
            alert(`Failed to load "${path}": ${err.message}`);
            loading.classList.remove('active');
        }
    }

    function clearModelSelection() {
        // Legacy function - model catalog not used in Gold editor
        const modelItems = document.querySelectorAll('.model-item');
        if (modelItems.length > 0) {
            modelItems.forEach(el => el.classList.remove('active'));
        }
    }

    function updateInfo(meta, resolvedPath, stats, sourceLabel = 'Catalog') {
        const infoPanel = document.getElementById('info-panel');
        if (!infoPanel) return; // Element removed, skip
        
        infoPanel.style.display = 'block';
        
        const setIfExists = (id, value) => {
            const el = document.getElementById(id);
            if (el) el.textContent = value;
        };
        
        setIfExists('info-title', meta?.name || meta?.filename || 'Manual Scene');
        setIfExists('info-source', sourceLabel);
        setIfExists('info-file', meta?.filename || 'â€”');
        setIfExists('info-author', meta?.author || 'unknown');
        setIfExists('info-size', meta?.size ? formatBytes(meta.size) : 'â€”');
        setIfExists('info-path', resolvedPath || meta?.path || meta?.filename || 'â€”');
        setIfExists('info-stats', formatStats(stats || WAG.viewer?.getStats()));
        setIfExists('info-notes', (meta?.description && meta.description !== meta.filename) ? meta.description : 'â€”');
    }

    function updateStats(query = '') {
        const stats = document.getElementById('stats');
        const total = WAG.models.length;
        if (!total) {
            stats.textContent = '0 models indexed';
            return;
        }
        const quarantinedCount = WAG.quarantinedFiles?.length || 0;
        if (query) {
            stats.textContent = `${WAG.filtered.length}/${total} match "${query}"`;
        } else {
            const suffix = quarantinedCount ? ` | ${quarantinedCount} quarantined` : '';
            stats.textContent = `${total} models ready${suffix}`;
        }
    }

    function formatStats(stats) {
        if (!stats) return 'â€”';
        return `Meshes: ${stats.meshes} â€¢ Lines: ${stats.lines} â€¢ Tris: ${stats.triangles}`;
    }

    function formatBytes(bytes = 0) {
        if (!bytes) return '0 B';
        const k = 1024;
        const sizes = ['B', 'KB', 'MB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return `${(bytes / Math.pow(k, i)).toFixed(1)} ${sizes[i]}`;
    }

    function setToggleButtonState(button, active) {
        if (!button) return;
        button.classList.toggle('active', !!active);
        if (button.id === 'toggle-spin') {
            button.textContent = active ? 'Stop Spin' : 'Auto Spin';
        }
    }

    init().then(() => {
        try {
            const params = new URLSearchParams(window.location.search);
            const mpd = params.get('mpd');
            if (mpd) {
                const decoded = decodeURIComponent(mpd);
                loadManualPath(decoded);
            }
        } catch (err) {
            console.warn('[WAG] mpd autoload failed', err);
        }
    });
    </script>
</body>
</html>
