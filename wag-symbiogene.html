<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>The Courage Manual</title>
    <link rel="icon"
        href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='80' font-size='80'>üçä</text></svg>">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        /* --- COURAGE THEME VARIABLES --- */
        :root {
            --bg-main: #0a0a0a;
            --bg-secondary: #151515;
            --bg-tertiary: #1f1f1f;
            --text-primary: #e8e8e8;
            --text-secondary: #b8b8b8;
            --border-primary: #2a2a2a;
            --accent: #ffd700;
            --accent-glow: rgba(255, 215, 0, 0.3);
            --val-pos: #ffd700;
            /* Gold */
            --val-neg: #ff6b6b;
            /* Soft Red */
            --val-zero: #888888;
            /* Grey */
            --code-bg: #000000;
            --gutter-bg: #111111;
            --gutter-text: #555555;

            /* Axis Colors */
            --axis-x: #ff4444;
            --axis-y: #44ff44;
            --axis-z: #4444ff;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
        }

        body {
            font-family: 'Courier New', monospace;
            background: var(--bg-main);
            color: var(--text-primary);
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        /* --- HEADER --- */
        .main-header {
            background: linear-gradient(180deg, var(--bg-tertiary) 0%, var(--bg-secondary) 100%);
            border-bottom: 1px solid var(--border-primary);
            height: 44px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 12px;
            flex-shrink: 0;
            z-index: 100;
        }

        .brand {
            font-size: 14px;
            color: var(--accent);
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
            text-shadow: 0 0 10px var(--accent-glow);
        }

        .main-nav {
            display: flex;
            gap: 4px;
            height: 100%;
            align-items: center;
            overflow-x: auto;
        }

        .nav-tab {
            background: transparent;
            border: 1px solid transparent;
            color: var(--text-secondary);
            font-family: 'Courier New', monospace;
            font-size: 12px;
            padding: 4px 12px;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s;
            white-space: nowrap;
            font-weight: 600;
        }

        .nav-tab:hover {
            color: var(--text-primary);
            background: var(--bg-tertiary);
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.3);
        }

        .nav-tab.active {
            color: var(--bg-main);
            background: var(--accent);
            font-weight: 800;
            box-shadow: 0 0 15px var(--accent-glow);
        }

        /* --- CONTENT AREA --- */
        .main-content {
            flex: 1;
            overflow: hidden;
            position: relative;
            background: var(--bg-main);
        }

        .section-view {
            display: none;
            width: 100%;
            height: 100%;
            overflow-y: auto;
            padding: 20px;
            opacity: 0;
            transform: translateY(10px);
            transition: opacity 0.3s ease, transform 0.3s ease;
        }

        .section-view.active {
            display: block;
            opacity: 1;
            transform: translateY(0);
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            padding-bottom: 60px;
        }

        /* --- CARDS & UI --- */
        .card {
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 8px;
            padding: 24px;
            margin-bottom: 24px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        .card-title {
            font-size: 16px;
            color: var(--accent);
            margin-bottom: 16px;
            font-weight: 800;
            text-transform: uppercase;
            letter-spacing: 1px;
            border-bottom: 1px solid var(--border-primary);
            padding-bottom: 8px;
            text-shadow: 0 0 10px var(--accent-glow);
        }

        .text {
            font-size: 13px;
            line-height: 1.6;
            color: var(--text-primary);
            margin-bottom: 16px;
        }

        .highlight {
            color: var(--accent);
            font-weight: 700;
        }

        /* --- REAL EDITOR STYLING --- */
        .editor-block {
            background: var(--code-bg);
            border: 1px solid var(--border-primary);
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.5;
            overflow-x: auto;
            position: relative;
            box-shadow: inset 0 2px 10px rgba(0, 0, 0, 0.5);
            transition: transform 0.2s ease;
        }

        .editor-line {
            display: flex;
            padding: 4px 0;
            transition: background 0.2s;
        }

        .editor-line.active {
            background: rgba(255, 215, 0, 0.05);
            box-shadow: inset 2px 0 0 var(--accent);
        }

        .gutter {
            background: var(--gutter-bg);
            color: var(--gutter-text);
            padding: 0 12px;
            text-align: right;
            min-width: 40px;
            border-right: 1px solid var(--border-primary);
            user-select: none;
        }

        .code-content {
            padding: 0 12px;
            color: #ccc;
            white-space: pre;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        /* --- EXPLICIT LABELS --- */
        .label-row {
            display: flex;
            padding: 0 12px;
            margin-left: 40px;
            gap: 12px;
            margin-bottom: 4px;
            pointer-events: none;
        }

        .col-label {
            font-size: 9px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            text-align: center;
            min-width: 24px;
        }

        .col-label.label-x {
            color: var(--axis-x);
            font-weight: bold;
            text-shadow: 0 0 5px rgba(255, 68, 68, 0.4);
        }

        .col-label.label-y {
            color: var(--axis-y);
            font-weight: bold;
            text-shadow: 0 0 5px rgba(68, 255, 68, 0.4);
        }

        .col-label.label-z {
            color: var(--axis-z);
            font-weight: bold;
            text-shadow: 0 0 5px rgba(68, 68, 255, 0.4);
        }

        /* --- HAPTIC DIALS --- */
        .dial {
            cursor: ns-resize;
            position: relative;
            transition: all 0.1s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            display: inline-block;
            padding: 2px 4px;
            border-radius: 4px;
            min-width: 24px;
            text-align: center;
        }

        .dial.static {
            cursor: default;
        }

        .dial.pos {
            color: var(--val-pos);
        }

        .dial.neg {
            color: var(--val-neg);
        }

        .dial.zero {
            color: var(--val-zero);
        }

        .dial:not(.static):hover {
            background: rgba(255, 255, 255, 0.1);
            z-index: 10;
            text-shadow: 0 0 8px currentColor;
        }

        .dial.dragging {
            background: var(--accent);
            color: var(--bg-main) !important;
            transform: scale(1.1);
            box-shadow: 0 0 15px var(--accent);
            z-index: 20;
            font-weight: bold;
        }

        /* --- GHOST HUD --- */
        .ghost-hud {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            text-align: center;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 50;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.8);
        }

        .ghost-hud.visible {
            opacity: 1;
        }

        .hud-label {
            font-size: 12px;
            color: var(--text-secondary);
            letter-spacing: 2px;
            text-transform: uppercase;
            margin-bottom: 4px;
        }

        .hud-value {
            font-size: 48px;
            font-weight: 800;
            color: var(--accent);
            font-family: 'Courier New', monospace;
            text-shadow: 0 0 20px var(--accent-glow);
        }

        /* --- CANVAS CONTAINERS --- */
        .viz-canvas {
            width: 100%;
            height: 300px;
            background: #050505;
            border: 1px solid var(--border-primary);
            margin-bottom: 20px;
            position: relative;
            overflow: hidden;
        }

        /* --- GIZMO LAYOUT --- */
        .gizmo-layout {
            display: flex;
            flex-direction: column;
            gap: 0;
        }

        /* --- STRUCTURE: THE STACK --- */
        .stack-container {
            display: flex;
            flex-direction: column;
            gap: 12px;
            position: relative;
        }

        .stack-block {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-primary);
            border-radius: 4px;
            padding: 12px;
            position: relative;
            transition: all 0.3s;
        }

        .stack-block.active {
            border-color: var(--accent);
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.1);
            transform: scale(1.02);
            z-index: 10;
        }

        .stack-header {
            font-size: 10px;
            color: var(--text-secondary);
            text-transform: uppercase;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
        }

        .stack-line {
            font-family: 'Courier New', monospace;
            font-size: 13px;
            color: #ccc;
            padding: 2px 0;
            cursor: pointer;
        }

        .stack-line:hover {
            color: var(--accent);
        }

        .stack-connector {
            position: absolute;
            left: 20px;
            width: 2px;
            background: var(--border-primary);
            z-index: 0;
        }

        /* --- MODES: TRINITY UI --- */
        .trinity-ui {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 20px;
        }

        .trinity-btn {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-primary);
            color: var(--text-secondary);
            padding: 10px 20px;
            border-radius: 20px;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .trinity-btn:hover {
            border-color: var(--accent);
            color: var(--text-primary);
        }

        .trinity-btn.active {
            background: var(--accent);
            color: var(--bg-main);
            box-shadow: 0 0 15px var(--accent-glow);
        }

        /* --- COMMANDS: TIMELINE UI --- */
        .timeline-controls {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-primary);
            border-radius: 4px;
            margin-bottom: 12px;
        }

        .timeline-slider {
            flex: 1;
            -webkit-appearance: none;
            height: 4px;
            background: var(--border-primary);
            border-radius: 2px;
            outline: none;
        }

        .timeline-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: var(--accent);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px var(--accent);
        }

        .floating-label {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: var(--accent);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            border: 1px solid var(--accent);
            box-shadow: 0 0 10px var(--accent-glow);
            transform: translate(-50%, -50%);
            white-space: nowrap;
        }
    </style>
</head>

<body>

    <header class="main-header">
        <div class="brand">
            <span>üß°</span> COURAGE MANUAL
        </div>
        <nav class="main-nav">
            <button class="nav-tab active" onclick="switchTab('start')">START</button>
            <button class="nav-tab" onclick="switchTab('atoms')">ATOMS</button>
            <button class="nav-tab" onclick="switchTab('workflow')">WORKFLOW</button>
            <button class="nav-tab" onclick="switchTab('dna')">DNA</button>
            <button class="nav-tab" onclick="switchTab('structure')">STRUCTURE</button>
            <button class="nav-tab" onclick="switchTab('modes')">MODES</button>
            <button class="nav-tab" onclick="switchTab('commands')">COMMANDS</button>
        </nav>
    </header>

    <main class="main-content">

        <!-- === TAB 1: START (THE SEED) === -->
        <div id="start" class="section-view active">
            <div class="container">
                <div class="card" style="text-align: center; padding: 30px;">
                    <div style="font-size: 40px; margin-bottom: 10px;">üå±</div>
                    <div class="card-title" style="border: none;">The Reality Shaper</div>
                    <div class="explanation">
                        Move on the <span class="highlight">Holodeck Grid</span>.<br>
                        Watch the <span class="highlight">Dimensions</span> update in real-time.
                    </div>
                </div>

                <div class="card">
                    <!-- REAL 3D CANVAS -->
                    <div class="viz-canvas" id="seed-canvas">
                        <div id="seed-hud" class="ghost-hud">
                            <div class="hud-label">PARAMETER</div>
                            <div class="hud-value">0</div>
                        </div>
                    </div>

                    <!-- Export LDraw Button -->
                    <button onclick="generateLDrawCode()" style="
                        margin-top: 12px;
                        padding: 8px 16px;
                        background: var(--accent);
                        color: var(--bg-main);
                        border: none;
                        border-radius: 4px;
                        font-weight: 700;
                        font-size: 11px;
                        cursor: pointer;
                        font-family: 'Courier New', monospace;
                        text-transform: uppercase;
                        letter-spacing: 1px;
                    ">üìã Export LDraw Code</button>

                    <!-- Status Text -->
                    <div id="status-text" style="margin-top: 8px; font-size: 11px; color: var(--text-secondary);">Ready
                    </div>
                </div>

                <div class="label-row">
                    <div class="col-label" style="width:24px;">TYPE</div>
                    <div class="col-label" style="width:24px;">COL</div>
                    <div class="col-label label-x" style="width:24px;">X</div>
                    <div class="col-label label-y" style="width:24px;">Y</div>
                    <div class="col-label label-z" style="width:24px;">Z</div>
                    <div class="col-label" style="width:100px;">ROTATION MATRIX</div>
                    <div class="col-label">PART</div>
                </div>

                <div class="editor-block" id="seed-editor">
                    <div class="editor-line">
                        <div class="gutter">1</div>
                        <div class="code-content">
                            <span class="dial pos" data-type="type" data-label="TYPE" data-min="1" data-max="1"
                                data-val="1">1</span>
                            <span class="dial pos" data-type="color" data-label="COLOR" data-min="0" data-max="15"
                                data-val="14">14</span>
                            <span class="dial zero" data-type="pos-x" data-label="X POS" data-min="-100" data-max="100"
                                data-val="0">0</span>
                            <span class="dial zero" data-type="pos-y" data-label="Y POS" data-min="-100" data-max="100"
                                data-val="0">0</span>
                            <span class="dial zero" data-type="pos-z" data-label="Z POS" data-min="-100" data-max="100"
                                data-val="0">0</span>
                            <span style="color: #555;">1 0 0 0 1 0 0 0 1</span>
                            <span style="color: var(--success);">3001.dat</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        </div>

        <!-- === TAB 2: ATOMS (PRIMITIVES) === -->
        <div id="atoms" class="section-view">
            <div class="container">
                <div class="card">
                    <div class="card-title">The Atoms</div>
                    <div class="text">
                        Bricks are made of <span class="highlight">Lines</span>, <span
                            class="highlight">Triangles</span>, and <span class="highlight">Quads</span>.
                    </div>

                    <div class="viz-canvas" id="atoms-canvas">
                        <div id="atoms-hud" class="ghost-hud">
                            <div class="hud-label">VERTEX</div>
                            <div class="hud-value">0</div>
                        </div>
                    </div>

                    <div class="editor-block" style="padding: 20px;">
                        <div class="text" style="color: #888;">// A Quad (Type 4)</div>
                        <div class="label-row" style="margin-left: 40px;">
                            <div class="col-label">TYPE</div>
                            <div class="col-label">COL</div>
                            <div class="col-label label-x">X1</div>
                            <div class="col-label label-y">Y1</div>
                            <div class="col-label label-z">Z1</div>
                            <div class="col-label label-x">X2</div>
                            <div class="col-label label-y">Y2</div>
                            <div class="col-label label-z">Z2</div>
                            <div class="col-label">...</div>
                        </div>
                        <div class="editor-line">
                            <div class="gutter">1</div>
                            <div class="code-content">
                                <span class="dial static pos">4</span>
                                <span class="dial static pos">16</span>
                                <span class="dial pos" data-type="v1x" data-label="V1 X" data-val="-10">-10</span>
                                <span class="dial pos" data-type="v1y" data-label="V1 Y" data-val="-10">-10</span>
                                <span class="dial pos" data-type="v1z" data-label="V1 Z" data-val="0">0</span>
                                <span class="dial pos" data-type="v2x" data-label="V2 X" data-val="10">10</span>
                                <span class="dial pos" data-type="v2y" data-label="V2 Y" data-val="-10">-10</span>
                                <span class="dial pos" data-type="v2z" data-label="V2 Z" data-val="0">0</span>
                                <span style="color: #555;">...</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- === TAB 3: WORKFLOW === -->
        <div id="workflow" class="section-view">
            <div class="container">
                <div class="card">
                    <div class="card-title">The Loop</div>
                    <div class="text">
                        1. <strong>Browser</strong>: Find a part.<br>
                        2. <strong>Editor</strong>: Drag the numbers to place it.<br>
                        3. <strong>Viewer</strong>: See it happen.
                    </div>
                    <div class="editor-block" style="padding: 20px;">

                        <div class="text" style="color: #888;">// Example Scene</div>
                        <div class="editor-line">
                            <div class="gutter">1</div>
                            <div class="code-content">
                                <span class="dial static pos">1</span>
                                <span class="dial static pos">4</span>
                                <span class="dial static zero">0</span>
                                <span class="dial static zero">0</span>
                                <span class="dial static zero">0</span>
                                <span style="color: #555;">1 0 0 0 1 0 0 0 1</span>
                                <span style="color: var(--success);">3001.dat</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- === TAB 4: DNA (GIZMO) === -->
        <div id="dna" class="section-view">
            <div class="container">
                <div class="card">
                    <div class="card-title">Rotation Matrix</div>
                    <div class="text">
                        The 9 numbers in the middle control rotation. <br>
                        Drag them directly to spin the Gizmo.
                    </div>

                    <div class="gizmo-layout">
                        <div class="viz-canvas" id="gizmo-canvas">
                            <div id="gizmo-hud" class="ghost-hud">
                                <div class="hud-label">MATRIX</div>
                                <div class="hud-value">0.0</div>
                            </div>
                        </div>

                        <div class="label-row"
                            style="margin-left: 40px; border-top: 1px solid var(--border-primary); margin-top: 0; padding-top: 8px;">
                            <div class="col-label" style="width:24px;">TYPE</div>
                            <div class="col-label" style="width:24px;">COL</div>
                            <div class="col-label label-x" style="width:24px;">X</div>
                            <div class="col-label label-y" style="width:24px;">Y</div>
                            <div class="col-label label-z" style="width:24px;">Z</div>
                            <div class="col-label label-x" style="width:24px;">M0</div>
                            <div class="col-label label-x" style="width:24px;">M1</div>
                            <div class="col-label label-x" style="width:24px;">M2</div>
                            <div class="col-label label-y" style="width:24px;">M3</div>
                            <div class="col-label label-y" style="width:24px;">M4</div>
                            <div class="col-label label-y" style="width:24px;">M5</div>
                            <div class="col-label label-z" style="width:24px;">M6</div>
                            <div class="col-label label-z" style="width:24px;">M7</div>
                            <div class="col-label label-z" style="width:24px;">M8</div>
                            <div class="col-label">PART</div>
                        </div>

                        <div class="editor-block" style="border-top: none; border-radius: 0 0 4px 4px;">
                            <div class="editor-line">
                                <div class="gutter">1</div>
                                <div class="code-content">
                                    <span class="dial static pos">1</span>
                                    <span class="dial static pos">14</span>
                                    <span class="dial static zero">0</span>
                                    <span class="dial static zero">0</span>
                                    <span class="dial static zero">0</span>

                                    <span class="dial pos" data-type="m0" data-label="M[0]" data-min="-1" data-max="1"
                                        data-step="0.1" data-val="1">1.0</span>
                                    <span class="dial zero" data-type="m1" data-label="M[1]" data-min="-1" data-max="1"
                                        data-step="0.1" data-val="0">0.0</span>
                                    <span class="dial zero" data-type="m2" data-label="M[2]" data-min="-1" data-max="1"
                                        data-step="0.1" data-val="0">0.0</span>

                                    <span class="dial zero" data-type="m3" data-label="M[3]" data-min="-1" data-max="1"
                                        data-step="0.1" data-val="0">0.0</span>
                                    <span class="dial pos" data-type="m4" data-label="M[4]" data-min="-1" data-max="1"
                                        data-step="0.1" data-val="1">1.0</span>
                                    <span class="dial zero" data-type="m5" data-label="M[5]" data-min="-1" data-max="1"
                                        data-step="0.1" data-val="0">0.0</span>

                                    <span class="dial zero" data-type="m6" data-label="M[6]" data-min="-1" data-max="1"
                                        data-step="0.1" data-val="0">0.0</span>
                                    <span class="dial zero" data-type="m7" data-label="M[7]" data-min="-1" data-max="1"
                                        data-step="0.1" data-val="0">0.0</span>
                                    <span class="dial pos" data-type="m8" data-label="M[8]" data-min="-1" data-max="1"
                                        data-step="0.1" data-val="1">1.0</span>

                                    <span style="color: var(--success);">3001.dat</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- === TAB 5: STRUCTURE (THE STACK) === -->
        <div id="structure" class="section-view">
            <div class="container">
                <div class="card">
                    <div class="card-title">The Stack (Single-File MPD)</div>
                    <div class="text">
                        We use a <span class="highlight">Single MPD File</span>. Sub-models are defined inside the same
                        file using <span class="highlight">0 FILE</span>.
                    </div>

                    <div class="stack-container">
                        <div class="stack-connector" style="height: 100%;"></div>

                        <!-- Main Model -->
                        <div class="stack-block active" id="stack-main">
                            <div class="stack-header">
                                <span>MAIN MODEL</span>
                                <span>main.ldr</span>
                            </div>
                            <div class="stack-line"><span style="color:#888">0</span> <span
                                    style="color:#ccc">FILE</span> main.ldr</div>
                            <div class="stack-line" onclick="highlightStack('stack-car')">
                                <span style="color:var(--val-pos)">1</span> 14 0 0 0 ... <span
                                    class="highlight">car.ldr</span>
                            </div>
                            <div class="stack-line"><span style="color:#888">0</span> <span
                                    style="color:#ccc">NOFILE</span></div>
                        </div>

                        <!-- Sub Model -->
                        <div class="stack-block" id="stack-car" style="margin-left: 20px;">
                            <div class="stack-header">
                                <span>SUB MODEL</span>
                                <span>car.ldr</span>
                            </div>
                            <div class="stack-line"><span style="color:#888">0</span> <span
                                    style="color:#ccc">FILE</span> car.ldr</div>
                            <div class="stack-line" onclick="highlightStack('stack-wheel')">
                                <span style="color:var(--val-pos)">1</span> 4 20 0 0 ... <span
                                    class="highlight">wheel.ldr</span>
                            </div>
                            <div class="stack-line"><span style="color:#888">0</span> <span
                                    style="color:#ccc">NOFILE</span></div>
                        </div>

                        <!-- Leaf Model -->
                        <div class="stack-block" id="stack-wheel" style="margin-left: 40px;">
                            <div class="stack-header">
                                <span>SUB MODEL</span>
                                <span>wheel.ldr</span>
                            </div>
                            <div class="stack-line"><span style="color:#888">0</span> <span
                                    style="color:#ccc">FILE</span> wheel.ldr</div>
                            <div class="stack-line">
                                <span style="color:var(--val-pos)">1</span> 71 0 0 0 ... 3001.dat
                            </div>
                            <div class="stack-line"><span style="color:#888">0</span> <span
                                    style="color:#ccc">NOFILE</span></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- === TAB 6: MODES (THE TRINITY) === -->
        <div id="modes" class="section-view">
            <div class="container">
                <div class="card">
                    <div class="card-title">The Trinity</div>
                    <div class="trinity-ui">
                        <button class="trinity-btn active" id="btn-swiss" onclick="setMode('swiss')">
                            <span>üëÜ</span> SWISS
                        </button>
                        <button class="trinity-btn" id="btn-frank" onclick="setMode('frank')">
                            <span>‚ú•</span> FRANK
                        </button>
                        <button class="trinity-btn" id="btn-grace" onclick="setMode('grace')">
                            <span>üé®</span> GRACE
                        </button>
                    </div>

                    <div class="viz-canvas" id="modes-canvas">
                        <!-- Canvas for Interactive Modes -->
                    </div>

                    <div class="text" id="mode-desc" style="margin-top: 20px; text-align: center;">
                        Select bricks with precision.
                    </div>
                </div>
            </div>
        </div>

        <!-- === TAB 7: COMMANDS (THE TIMELINE) === -->
        <div id="commands" class="section-view">
            <div class="container">
                <div class="card">
                    <div class="card-title">The Timeline</div>
                    <div class="text">
                        Control the flow of time with <span class="highlight">0 STEP</span> and annotate with <span
                            class="highlight">0 WRITE</span>.
                    </div>

                    <div class="timeline-controls">
                        <span style="font-size: 20px;">‚èÆ</span>
                        <input type="range" min="1" max="3" value="3" class="timeline-slider" id="step-slider"
                            oninput="updateStep(this.value)">
                        <span style="font-size: 20px;">‚è≠</span>
                    </div>

                    <div class="viz-canvas" id="commands-canvas" style="position: relative;">
                        <!-- Floating Labels will be injected here -->
                    </div>

                    <div class="editor-block" style="margin-top: 20px;">
                        <div class="editor-line">
                            <div class="gutter">1</div>
                            <div class="code-content">
                                <span style="color:var(--val-pos)">1</span> ... <span
                                    style="color:var(--success)">3001.dat</span>
                            </div>
                        </div>
                        <div class="editor-line">
                            <div class="gutter">2</div>
                            <div class="code-content">
                                <span style="color:#888">0</span> <span style="color:#ccc">STEP</span>
                            </div>
                        </div>
                        <div class="editor-line">
                            <div class="gutter">3</div>
                            <div class="code-content">
                                <span style="color:#888">0</span> <span style="color:#ccc">WRITE</span> <span
                                    style="color:var(--accent)">"Base Complete"</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

    </main>

    <script>
        // --- STATE MANAGEMENT ---
        const state = {
            seed: { x: 0, y: 0, z: 0, color: 14, rot: 0 },
            // --- MULTI-BRICK STATE ---
            editorLines: [
                "1 14 0 24 0 1 0 0 0 1 0 0 0 1 3004.dat", // Start with one brick
            ],
            brickObjects: [], // Three.js meshes with userData.lineNum
            selectedLineIndex: 0, // Currently selected line
            matrix: [1, 0, 0, 0, 1, 0, 0, 0, 1],
            atoms: { v1: { x: -10, y: -10, z: 0 }, v2: { x: 10, y: -10, z: 0 } },
            mode: 'swiss',
            step: 3
        };

        // --- LDRAW COLOR MAP ---
        const ldrawColors = {
            0: 0x111111, // Black
            1: 0x0055BF, // Blue
            2: 0x257A24, // Green
            3: 0x008F9B, // Dark Turquoise
            4: 0xC91A09, // Red
            5: 0xC870A0, // Dark Pink
            6: 0x583927, // Brown
            7: 0x9BA19D, // Light Gray
            8: 0x6D6E5C, // Dark Gray
            9: 0xB4D2E3, // Light Blue
            10: 0x4B9F4A, // Bright Green
            11: 0x55A5AF, // Light Turquoise
            12: 0xF2705E, // Salmon
            13: 0xFC97AC, // Pink
            14: 0xFFD700, // Yellow (Gold for Courage)
            15: 0xF2F3F3  // White
        };

        // --- AUDIO ENGINE (MANUAL.HTML RATCHET) ---
        let synth; // MembraneSynth for "Lucid Thud"
        let audioEnabled = false;
        let lastQuadrant = 0;
        let lastDragTime = 0;
        let lastDragVal = 0;

        async function initAudio() {
            if (audioEnabled) return;
            await Tone.start();

            // RESTORED FROM MANUAL.HTML
            // Polished MembraneSynth for "Lucid Mid Tone"
            // Less pitch decay = less "pew", more "thud"
            synth = new Tone.MembraneSynth({
                pitchDecay: 0.02,
                octaves: 1.5,
                oscillator: { type: "sine" },
                envelope: { attack: 0.005, decay: 0.08, sustain: 0, release: 0.1 }
            }).toDestination();
            synth.volume.value = -14; // Polite volume

            audioEnabled = true;
        }

        // Audio Functions (Manual.html Style)
        function playTick() {
            if (audioEnabled && synth) synth.triggerAttackRelease("C1", "32n");
        }

        function playSnap() {
            if (audioEnabled && synth) synth.triggerAttackRelease("E1", "32n");
        }

        function playChord() {
            if (audioEnabled && synth) synth.triggerAttackRelease("G1", "16n");
        }

        function playSweep(axis) {
            if (!audioEnabled || !synth) return;
            if (axis === 'x') synth.triggerAttackRelease("G1", "16n");
            if (axis === 'z') synth.triggerAttackRelease("C1", "16n");
        }

        // --- HELPER: TEXT SPRITES ---
        function createTextSprite(message, color) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 128;

            ctx.fillStyle = color;
            ctx.font = "Bold 60px Courier New";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(message, 128, 64);

            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture, transparent: true });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(20, 10, 1);
            return sprite;
        }

        // --- REAL 3D SEED (THREE.JS) ---
        let seedScene, seedCamera, seedRenderer, seedBrick, seedGrid;
        let seedHelpers = {
            dimsX: null, dimsZ: null, dimsY: null,
            labelX: null, labelZ: null, labelY: null,
            cornerLines: null,
            activeRailX: null, activeRailZ: null,
            controlHub: null,
            gridMajor: null, gridMinor: null,
            snapGlow: null,
            // Skeleton-specific helpers
            skeletonGroup: null,
            skeletonBonesGroup: null
        };

        // Raycasting for 3D Sliders
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let isDragging3D = false;
        let dragAxis = null; // 'x', 'y', 'z'
        let dragOffset = 0;
        let controls; // Scope controls to disable them

        // --- CUBE CORNER POINTS (Spatial Reference) ---
        let cubePoints;
        function initCubePoints() {
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            // 8 corners of the brick (20x24x40)
            // Relative to center (0,12,0)
            const w = 10; const h = 12; const d = 20;
            const corners = [
                { x: -w, y: -h, z: -d }, { x: w, y: -h, z: -d },
                { x: -w, y: -h, z: d }, { x: w, y: -h, z: d },
                { x: -w, y: h, z: -d }, { x: w, y: h, z: -d },
                { x: -w, y: h, z: d }, { x: w, y: h, z: d }
            ];

            corners.forEach(c => vertices.push(c.x, c.y, c.z));

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));

            const material = new THREE.PointsMaterial({
                color: 0x00ffff, // Cyan to match grid
                size: 6, // Bigger so they're visible
                sizeAttenuation: true,
                transparent: true,
                opacity: 1.0 // Fully visible
            });

            cubePoints = new THREE.Points(geometry, material);
            seedBrick.add(cubePoints); // Attach to brick so it moves with it
        }

        function initSeed() {
            if (seedRenderer) return;
            const container = document.getElementById('seed-canvas');
            const w = container.clientWidth;
            const h = container.clientHeight;

            seedScene = new THREE.Scene();
            seedScene.background = new THREE.Color(0x050505);

            // Camera
            seedCamera = new THREE.PerspectiveCamera(45, w / h, 0.1, 1000);
            seedCamera.position.set(100, 120, 100);
            seedCamera.lookAt(0, 0, 0);

            // Renderer
            seedRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            seedRenderer.setSize(w, h);
            container.appendChild(seedRenderer.domElement);

            // Controls
            controls = new THREE.OrbitControls(seedCamera, seedRenderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            // --- LASER LATTICE (HOLODECK) ---
            const planeGeo = new THREE.PlaneGeometry(400, 400);
            const planeMat = new THREE.MeshBasicMaterial({ color: 0x050505, side: THREE.DoubleSide }); // Darker floor
            const plane = new THREE.Mesh(planeGeo, planeMat);
            plane.rotation.x = -Math.PI / 2;
            plane.position.y = -0.1;
            seedScene.add(plane);

            // Plane for Raycasting (Ground)
            plane.name = "ground";

            // VISIBLE LEGO GRID: 20 LDU spacing (1x1 studs)
            // Bright, clear, easy to count
            // Size 200, Divisions 10 -> 20 LDU per square
            seedHelpers.gridMajor = new THREE.GridHelper(200, 10, 0x00ffff, 0x0088ff);
            seedHelpers.gridMajor.material.transparent = false; // Solid
            seedScene.add(seedHelpers.gridMajor);

            // Minor grid for precision (5 LDU)
            // Size 200, Divisions 40 -> 5 LDU
            seedHelpers.gridMinor = new THREE.GridHelper(200, 40, 0x006688, 0x003344);
            seedHelpers.gridMinor.material.transparent = true;
            seedHelpers.gridMinor.material.opacity = 0.4;
            seedScene.add(seedHelpers.gridMinor);

            // 3D VOLUME CAGE (Red wireframe showing full 3D space)
            // X: -100 to 100, Y: 0 to 200, Z: -100 to 100
            const cageGeo = new THREE.BoxGeometry(200, 200, 200);
            const cageEdges = new THREE.EdgesGeometry(cageGeo);
            const cageMat = new THREE.LineBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.3 });
            const cage = new THREE.LineSegments(cageEdges, cageMat);
            cage.position.y = 100; // Center at Y=100 (0 to 200)
            seedScene.add(cage);

            // Floor Plane (Will turn red on collision)
            const floorGeo = new THREE.PlaneGeometry(200, 200);
            const floorMat = new THREE.MeshBasicMaterial({ color: 0x0088ff, transparent: true, opacity: 0.1, side: THREE.DoubleSide });
            seedHelpers.floor = new THREE.Mesh(floorGeo, floorMat);
            seedHelpers.floor.rotation.x = -Math.PI / 2;
            seedHelpers.floor.position.y = 0;
            seedScene.add(seedHelpers.floor);

            // Initialize Mist Sprites
            initMistSprites();

            // Snap Glow Helper (Hidden by default)
            const glowGeo = new THREE.PlaneGeometry(20, 20);
            const glowMat = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.3, side: THREE.DoubleSide });
            seedHelpers.snapGlow = new THREE.Mesh(glowGeo, glowMat);
            seedHelpers.snapGlow.rotation.x = -Math.PI / 2;
            seedHelpers.snapGlow.visible = false;
            seedScene.add(seedHelpers.snapGlow);

            const axes = new THREE.AxesHelper(100);
            seedScene.add(axes);

            // --- THE BRICK (1x2 Studs) ---
            // 1 Stud = 20 LDU width, 20 LDU depth
            // 1 Brick Height = 24 LDU
            // 1x2 Brick = 20 x 24 x 40
            const geometry = new THREE.BoxGeometry(20, 24, 40);
            const material = new THREE.MeshStandardMaterial({
                color: 0xffd700,
                roughness: 0.3,
                metalness: 0.4,
                polygonOffset: true,
                polygonOffsetFactor: 1,
                polygonOffsetUnits: 1
            });
            seedBrick = new THREE.Mesh(geometry, material);
            seedBrick.position.set(0, 12, 0);
            seedScene.add(seedBrick);

            const edges = new THREE.EdgesGeometry(geometry);
            const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x000000 }));
            seedBrick.add(line);

            // Initialize Cube Points
            initCubePoints();

            // Initialize Corner Snaps (4 bottom corners)
            initCornerSnaps();

            // --- CONTROL HUB (ORIGIN) ---
            const hubGeo = new THREE.SphereGeometry(2, 16, 16);
            const hubMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            seedHelpers.controlHub = new THREE.Mesh(hubGeo, hubMat);
            seedBrick.add(seedHelpers.controlHub);

            // --- HELPERS ---

            // Active Rails
            const railMat = new THREE.LineBasicMaterial({ color: 0xffd700, transparent: true, opacity: 0.5 });
            const railGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(-200, 0, 0), new THREE.Vector3(200, 0, 0)]);

            seedHelpers.activeRailX = new THREE.Line(railGeo, railMat);
            seedHelpers.activeRailZ = new THREE.Line(railGeo, railMat);
            seedHelpers.activeRailZ.rotation.y = Math.PI / 2;

            seedScene.add(seedHelpers.activeRailX);
            seedScene.add(seedHelpers.activeRailZ);

            // Corner Guides
            const cornerGeo = new THREE.BufferGeometry();
            const positions = new Float32Array(8 * 3);
            cornerGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            seedHelpers.cornerLines = new THREE.LineSegments(cornerGeo, new THREE.LineBasicMaterial({ color: 0x444444, transparent: true, opacity: 0.5, dashSize: 4, gapSize: 2 }));
            seedScene.add(seedHelpers.cornerLines);

            // Dimension Lines & Labels
            seedHelpers.dimsX = new THREE.ArrowHelper(new THREE.Vector3(1, 0, 0), new THREE.Vector3(0, 0.1, 0), 0, 0xff4444, 10, 5);
            seedHelpers.dimsZ = new THREE.ArrowHelper(new THREE.Vector3(0, 0, 1), new THREE.Vector3(0, 0.1, 0), 0, 0x4444ff, 10, 5);
            seedHelpers.dimsY = new THREE.ArrowHelper(new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 0), 0, 0x44ff44, 10, 5);

            // Name them for Raycasting
            seedHelpers.dimsX.line.name = "lineX"; seedHelpers.dimsX.cone.name = "lineX";
            seedHelpers.dimsZ.line.name = "lineZ"; seedHelpers.dimsZ.cone.name = "lineZ";
            seedHelpers.dimsY.line.name = "lineY"; seedHelpers.dimsY.cone.name = "lineY";

            seedScene.add(seedHelpers.dimsX);
            seedScene.add(seedHelpers.dimsZ);
            seedScene.add(seedHelpers.dimsY);

            seedHelpers.labelX = createTextSprite("0", "#ff4444");
            seedHelpers.labelZ = createTextSprite("0", "#4444ff");
            seedHelpers.labelY = createTextSprite("0", "#44ff44");

            // Enable Raycasting on Sprites
            seedHelpers.labelX.name = "labelX";
            seedHelpers.labelZ.name = "labelZ";
            seedHelpers.labelY.name = "labelY";

            seedScene.add(seedHelpers.labelX);
            seedScene.add(seedHelpers.labelZ);
            seedScene.add(seedHelpers.labelY);

            // Lights
            const light = new THREE.DirectionalLight(0xffffff, 1.2);
            light.position.set(50, 100, 50);
            seedScene.add(light);
            seedScene.add(new THREE.AmbientLight(0xffffff, 0.3));

            const rimLight = new THREE.SpotLight(0xffd700, 0.5);
            rimLight.position.set(-50, 50, -50);
            rimLight.lookAt(0, 0, 0);
            seedScene.add(rimLight);

            // --- RAYCASTING EVENTS ---
            container.addEventListener('mousedown', onMouseDown);
            container.addEventListener('mousemove', onMouseMove);
            container.addEventListener('mouseup', onMouseUp);
            container.addEventListener('touchstart', onTouchStart, { passive: false });
            container.addEventListener('touchmove', onTouchMove, { passive: false });
            container.addEventListener('touchend', onMouseUp);

            animateSeed();
        }

        // --- SKELETON VISUALIZATION (FROM COURAGE stud_skeleton JSON) ---
        // Expected payload: Array of { x, y, z, layer?, lineNum? }
        function clearSkeletonVisualization() {
            if (!seedScene) return;
            if (seedHelpers.skeletonGroup && seedHelpers.skeletonGroup.parent) {
                seedHelpers.skeletonGroup.parent.remove(seedHelpers.skeletonGroup);
            }
            if (seedHelpers.skeletonBonesGroup && seedHelpers.skeletonBonesGroup.parent) {
                seedHelpers.skeletonBonesGroup.parent.remove(seedHelpers.skeletonBonesGroup);
            }
            seedHelpers.skeletonGroup = null;
            seedHelpers.skeletonBonesGroup = null;
        }

        function loadSkeletonFromStuds(studs) {
            if (!Array.isArray(studs) || !seedScene || !window.THREE) {
                console.warn('[SYMBIOGENE] loadSkeletonFromStuds: invalid input or scene');
                return;
            }

            clearSkeletonVisualization();

            const group = new THREE.Group();
            const bonesGroup = new THREE.Group();

            // Stud markers
            const normalMat = new THREE.MeshBasicMaterial({ color: 0x00ffff });
            const problemMat = new THREE.MeshBasicMaterial({ color: 0xff4444 });
            const ghostGeo = new THREE.SphereGeometry(2, 12, 12);

            const byLine = new Map();

            studs.forEach(node => {
                if (!node || typeof node.x !== 'number' || typeof node.y !== 'number' || typeof node.z !== 'number') {
                    return;
                }
                const isBelow = typeof node.layer === 'number' && typeof STATE !== 'undefined'
                    ? (typeof STATE.baseGridLayer === 'number' && node.layer < STATE.baseGridLayer)
                    : false;
                const marker = new THREE.Mesh(ghostGeo, isBelow ? problemMat : normalMat);
                marker.position.set(node.x, node.y, node.z);
                group.add(marker);

                const key = typeof node.lineNum === 'number' ? node.lineNum : null;
                if (key !== null) {
                    let arr = byLine.get(key);
                    if (!arr) {
                        arr = [];
                        byLine.set(key, arr);
                    }
                    arr.push(node);
                }
            });

            // Bones per MPD line
            byLine.forEach((nodes, lineNum) => {
                if (!nodes.length) return;
                const box = new THREE.Box3();
                nodes.forEach(n => box.expandByPoint(new THREE.Vector3(n.x, n.y, n.z)));

                const size = box.getSize(new THREE.Vector3());
                const center = box.getCenter(new THREE.Vector3());

                // Avoid degenerate boxes
                if (!isFinite(size.x) || !isFinite(size.y) || !isFinite(size.z)) return;
                const sx = size.x || 2;
                const sy = size.y || 2;
                const sz = size.z || 2;

                const geom = new THREE.BoxGeometry(sx, sy, sz);
                const mat = new THREE.MeshBasicMaterial({
                    color: 0x00ffff,
                    wireframe: true,
                    transparent: true,
                    opacity: 0.5
                });
                const bone = new THREE.Mesh(geom, mat);
                bone.position.copy(center);
                bone.userData.lineNum = lineNum;
                bonesGroup.add(bone);
            });

            seedScene.add(group);
            seedScene.add(bonesGroup);
            seedHelpers.skeletonGroup = group;
            seedHelpers.skeletonBonesGroup = bonesGroup;
            console.log('[SYMBIOGENE] Skeleton loaded with', studs.length, 'studs and', byLine.size, 'bones');
        }

        function getIntersects(event, container) {
            const rect = container.getBoundingClientRect();
            let clientX, clientY;

            if (event.changedTouches) {
                clientX = event.changedTouches[0].clientX;
                clientY = event.changedTouches[0].clientY;
            } else {
                clientX = event.clientX;
                clientY = event.clientY;
            }

            mouse.x = ((clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, seedCamera);

            // Intersect with Labels AND Lines (Control Surfaces)
            // We need to check the ArrowHelper children (line and cone)
            const objects = [
                seedHelpers.labelX, seedHelpers.labelZ, seedHelpers.labelY,
                seedHelpers.dimsX.line, seedHelpers.dimsX.cone,
                seedHelpers.dimsZ.line, seedHelpers.dimsZ.cone,
                seedHelpers.dimsY.line, seedHelpers.dimsY.cone
            ];
            return raycaster.intersectObjects(objects);
        }

        // Helper to get intersection point on a given plane
        function getIntersectionPoint(event, container, plane) {
            const rect = container.getBoundingClientRect();
            let clientX, clientY;

            if (event.changedTouches) {
                clientX = event.changedTouches[0].clientX;
                clientY = event.changedTouches[0].clientY;
            } else {
                clientX = event.clientX;
                clientY = event.clientY;
            }

            mouse.x = ((clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, seedCamera);

            const target = new THREE.Vector3();
            raycaster.ray.intersectPlane(plane, target);
            return target;
        }

        function onMouseDown(event) {
            initAudio();
            // Check if clicking on a dial or control first
            if (event.target.closest('.dial')) return;

            const container = document.getElementById('seed-canvas');
            const rect = container.getBoundingClientRect();
            const x = (event.clientX - rect.left) / rect.width * 2 - 1;
            const y = -(event.clientY - rect.top) / rect.height * 2 + 1;

            // Raycast for 3D controls (Arrows/Labels)
            const intersects = getIntersects(event, container);

            if (intersects.length > 0) {
                const obj = intersects[0].object;
                // Check for Labels or Lines
                if (obj.name.includes('labelX') || obj.name.includes('lineX')) {
                    isDragging3D = true; dragAxis = 'x';
                    controls.enabled = false;
                    playSnap();
                    startOrb(); // Start Drone
                }
                else if (obj.name.includes('labelZ') || obj.name.includes('lineZ')) {
                    isDragging3D = true; dragAxis = 'z';
                    controls.enabled = false;
                    playSnap();
                    startOrb(); // Start Drone
                }
                else if (obj.name.includes('labelY') || obj.name.includes('lineY')) {
                    isDragging3D = true; dragAxis = 'y';
                    controls.enabled = false;
                    playSnap();
                    startOrb(); // Start Drone
                }
            }
        }

        function onMouseMove(event) {
            if (!isDragging3D) return;
            const container = document.getElementById('seed-canvas');
            let point;
            let rawVal = 0;

            if (dragAxis === 'x') {
                point = getIntersectionPoint(event, container, new THREE.Plane(new THREE.Vector3(0, 1, 0), 0)); // Ground plane
                if (point) rawVal = point.x * 2;
            } else if (dragAxis === 'z') {
                point = getIntersectionPoint(event, container, new THREE.Plane(new THREE.Vector3(0, 1, 0), 0)); // Ground plane
                if (point) rawVal = point.z * 2;
            } else if (dragAxis === 'y') {
                // For Y-axis, project onto a vertical plane passing through current X, Z
                // This plane's normal is perpendicular to the camera's view direction in the XZ plane
                // and also perpendicular to the Y-axis.
                const cameraDir = new THREE.Vector3();
                seedCamera.getWorldDirection(cameraDir);
                cameraDir.y = 0; // Flatten to XZ plane
                cameraDir.normalize();

                // Create a plane perpendicular to cameraDir, passing through the brick's current X, Z
                const planeNormal = new THREE.Vector3(-cameraDir.z, 0, cameraDir.x); // Perpendicular to cameraDir in XZ
                const plane = new THREE.Plane();
                plane.setFromNormalAndCoplanarPoint(planeNormal, new THREE.Vector3(state.seed.x, 0, state.seed.z));

                point = getIntersectionPoint(event, container, plane);
                if (point) rawVal = point.y * 2; // Y-value from the intersection point
            }

            if (point) {
                // --- LIMIT LOGIC (+/- 100 LDU for X/Z, 0-200 for Y) ---
                let limitHit = false;
                if (dragAxis === 'x' || dragAxis === 'z') {
                    if (rawVal > 100) { rawVal = 100; limitHit = true; }
                    if (rawVal < -100) { rawVal = -100; limitHit = true; }
                } else if (dragAxis === 'y') {
                    if (rawVal > 200) { rawVal = 200; limitHit = true; }
                    if (rawVal < 0) { rawVal = 0; limitHit = true; }
                }

                // Mobile Haptic Feedback on Boundary Hit
                if (limitHit && navigator.vibrate) {
                    if (Math.abs(lastDragVal) < 100) {
                        navigator.vibrate(50); // Strong vibration at boundary
                    }
                }

                // --- STRONG MAGNETIC SNAPPING ---
                // Snap radius: 3 LDU (much tighter for "ratchet" feel)
                const snapPoint = Math.round(rawVal / 20) * 20;
                const dist = Math.abs(rawVal - snapPoint);

                let finalVal = rawVal;

                // STRONG SNAP: Once within 3 LDU, lock hard to grid
                if (dist < 3) {
                    finalVal = snapPoint;
                } else {
                    // "Viscosity": Dampen movement outside snap?
                    // Or just let it flow.
                    // Let's stick to the strong snap radius (8 LDU = 40% of a stud)
                    // This creates a "sticky" feel.
                }

                const newVal = finalVal;

                // Calculate Velocity
                const velocity = Math.abs(newVal - lastDragVal);

                // Play Tick if value changed
                if (Math.abs(newVal - lastDragVal) > 0.1) {
                    // Ratchet tick on movement
                    if (Math.floor(newVal / 20) !== Math.floor(lastDragVal / 20)) {
                        playTick(); // Manual.html style
                    }
                }

                lastDragVal = newVal;

                // Update State
                if (dragAxis === 'x') {
                    const oldX = state.seed.x;
                    state.seed.x = newVal;
                    if (Math.sign(oldX) !== Math.sign(newVal)) playSweep('x');
                }
                if (dragAxis === 'z') {
                    const oldZ = state.seed.z;
                    state.seed.z = newVal;
                    if (Math.sign(oldZ) !== Math.sign(newVal)) playSweep('z');
                }
                if (dragAxis === 'y') {
                    state.seed.y = newVal;
                }

                updateSeed();
                updateSpatialAudio(state.seed.x, state.seed.z);

                // Update Dials
                document.querySelectorAll('.dial').forEach(d => {
                    if (d.dataset.type === 'pos-x' && dragAxis === 'x') {
                        d.dataset.val = state.seed.x;
                        d.innerText = Math.round(state.seed.x);
                    }
                    if (d.dataset.type === 'pos-z' && dragAxis === 'z') {
                        d.dataset.val = state.seed.z;
                        d.innerText = Math.round(state.seed.z);
                    }
                    if (d.dataset.type === 'pos-y' && dragAxis === 'y') {
                        d.dataset.val = state.seed.y;
                        d.innerText = Math.round(state.seed.y);
                    }
                });
            }
        }

        function onMouseUp() {
            if (isDragging3D) {
                // SNAP-ON-RELEASE: If close to a grid point, snap to it
                if (dragAxis === 'x') {
                    const snapPoint = Math.round(state.seed.x / 20) * 20;
                    const dist = Math.abs(state.seed.x - snapPoint);
                    if (dist < 10) { // Within half a stud
                        state.seed.x = snapPoint;
                        playSnap();
                        if (navigator.vibrate) navigator.vibrate(15); // Snap haptic
                    }
                }
                if (dragAxis === 'z') {
                    const snapPoint = Math.round(state.seed.z / 20) * 20;
                    const dist = Math.abs(state.seed.z - snapPoint);
                    if (dist < 10) {
                        state.seed.z = snapPoint;
                        playSnap();
                        if (navigator.vibrate) navigator.vibrate(15);
                    }
                }
                if (dragAxis === 'y') {
                    const snapPoint = Math.round(state.seed.y / 20) * 20;
                    const dist = Math.abs(state.seed.y - snapPoint);
                    if (dist < 10) {
                        state.seed.y = snapPoint;
                        playSnap();
                        if (navigator.vibrate) navigator.vibrate(15);
                    }
                }

                updateSeed();
                playSnap();
                lastDragVal = 0;
            }
            isDragging3D = false;
            dragAxis = null;
            controls.enabled = true;
        }

        function onTouchStart(e) { e.preventDefault(); onMouseDown(e); }
        function onTouchMove(e) { e.preventDefault(); onMouseMove(e); }

        // --- LDRAW CODE GENERATOR ---
        function generateLDrawCode() {
            const x = state.seed.x;
            const y = state.seed.y;
            const z = state.seed.z;
            const color = Math.round(state.seed.color);

            // Standard 1x2 brick is 3004.dat
            const ldrawCode = `1 ${color} ${x} ${y} ${z} 1 0 0 0 1 0 0 0 1 3004.dat`;

            // Copy to clipboard
            navigator.clipboard.writeText(ldrawCode).then(() => {
                const statusEl = document.getElementById('status-text');
                if (statusEl) {
                    const oldText = statusEl.textContent;
                    statusEl.textContent = '‚úÖ LDraw code copied to clipboard!';
                    setTimeout(() => statusEl.textContent = oldText, 2000);
                }
            });

            console.log('LDraw Code:', ldrawCode);
            return ldrawCode;
        }

        // --- CORNER SNAP VISUALIZATION ---
        let cornerSnapHelpers = [];
        function initCornerSnaps() {
            // 4 bottom corners of the brick
            const w = 10; const d = 20;
            const offsets = [
                { x: -w, z: -d }, { x: w, z: -d },
                { x: -w, z: d }, { x: w, z: d }
            ];

            offsets.forEach(offset => {
                // Corner marker (small cyan sphere)
                const geo = new THREE.SphereGeometry(1.5, 8, 8);
                const mat = new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.8 });
                const marker = new THREE.Mesh(geo, mat);
                marker.userData = { offset };

                // Snap target (glowing ring on grid)
                const ringGeo = new THREE.RingGeometry(1, 2, 16);
                const ringMat = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0, side: THREE.DoubleSide });
                const ring = new THREE.Mesh(ringGeo, ringMat);
                ring.rotation.x = -Math.PI / 2;
                ring.position.y = 0.1;

                cornerSnapHelpers.push({ marker, ring, offset });
                seedScene.add(marker);
                seedScene.add(ring);
            });
        }

        function updateCornerSnaps(brickX, brickY, brickZ) {
            cornerSnapHelpers.forEach(helper => {
                const { marker, ring, offset } = helper;

                // Update marker position (follows brick)
                marker.position.set(
                    brickX + offset.x,
                    brickY, // Bottom of brick
                    brickZ + offset.z
                );

                // Calculate snap target (nearest 20 LDU grid point)
                const snapX = Math.round((brickX + offset.x) / 20) * 20;
                const snapZ = Math.round((brickZ + offset.z) / 20) * 20;

                ring.position.set(snapX, 0.1, snapZ);

                // Distance from corner to snap target
                const dx = (brickX + offset.x) - snapX;
                const dz = (brickZ + offset.z) - snapZ;
                const dist = Math.sqrt(dx * dx + dz * dz);

                //Show ring when close to snap point
                if (dist < 10) {
                    const intensity = 1 - (dist / 10);
                    ring.material.opacity = intensity * 0.6;
                    ring.scale.set(1 + intensity * 0.5, 1 + intensity * 0.5, 1);
                } else {
                    ring.material.opacity = 0;
                }
            });
        }
        // --- MIST PARTICLES ---
        let mistSprites = []; // FIXED: Re-declared array

        function initMistSprites() {
            const group = new THREE.Group();
            const material = new THREE.SpriteMaterial({
                color: 0x00ffff,
                transparent: true,
                opacity: 0.3, // Always slightly visible
                blending: THREE.AdditiveBlending
            });

            // PRECISION GRID DOTS - tiny controlled points of light
            for (let x = -100; x <= 100; x += 20) {
                for (let z = -100; z <= 100; z += 20) {
                    const sprite = new THREE.Sprite(material.clone());
                    sprite.position.set(x, 0.5, z);
                    sprite.scale.set(1.5, 1.5, 1); // TINY
                    sprite.userData = { baseOp: 0.3 };
                    group.add(sprite);
                    mistSprites.push(sprite);
                }
            }
            seedScene.add(group);
        }

        function animateMist(targetX, targetZ) {
            mistSprites.forEach(sprite => {
                const dx = sprite.position.x - targetX;
                const dz = sprite.position.z - targetZ;
                const dist = Math.sqrt(dx * dx + dz * dz);

                // ECHOLOCATION: Grid points "ping" when near
                // Always visible at base level, brighten when close
                if (dist < 30) {
                    const intensity = 1 - (dist / 30);
                    sprite.material.opacity = 0.3 + intensity * 0.7; // Brighten
                    sprite.scale.set(1.5, 1.5, 1); // Stay small
                } else {
                    sprite.material.opacity = 0.3; // Always faintly visible
                    sprite.scale.set(1.5, 1.5, 1);
                }
            });
        }

        function updateSeed() {
            if (!seedBrick) return;

            const x = state.seed.x;
            const y = state.seed.y;
            const z = state.seed.z;

            // 1. Update Brick
            seedBrick.position.set(x, y + 12, z);
            const hex = ldrawColors[Math.round(state.seed.color)] || 0xffd700;
            seedBrick.material.color.setHex(hex);

            // Update Mist
            animateMist(x, z);

            // Update Corner Snap Visualization
            updateCornerSnaps(x, y, z);

            // FLOOR COLLISION DETECTION with RESISTANCE
            // Bottom of brick is at y + 12 - 12 = y
            if (seedHelpers.floor) {
                if (y <= 0) {
                    // GROUND RESISTANCE: Clamp to floor, play collision sound
                    state.seed.y = 0;
                    seedBrick.position.y = 12; // Reset visual
                    seedHelpers.floor.material.color.setHex(0xff0000); // RED WARNING
                    seedHelpers.floor.material.opacity = 0.5;

                    // Play ground collision sound
                    if (membraneSynth) {
                        membraneSynth.triggerAttackRelease("C1", "8n");
                    }
                    if (navigator.vibrate) navigator.vibrate([30, 10, 30]); // Double thud
                } else if (y < 5) {
                    // Close to ground, subtle warning
                    const intensity = 1 - (y / 5);
                    seedHelpers.floor.material.color.setHex(0xff4400);
                    seedHelpers.floor.material.opacity = 0.1 + intensity * 0.2;
                } else {
                    seedHelpers.floor.material.color.setHex(0x0088ff); // Blue normal
                    seedHelpers.floor.material.opacity = 0.1;
                }
            }

            // 2. Update Active Rails
            seedHelpers.activeRailX.position.z = z;
            seedHelpers.activeRailZ.position.x = x;

            // Negative Logic for Rails
            const isNegative = x < 0 || z < 0 || y < 0;
            const railColor = isNegative ? 0xff0000 : 0xffd700;
            seedHelpers.activeRailX.material.color.setHex(railColor);
            seedHelpers.activeRailZ.material.color.setHex(railColor);

            // 3. Update Corner Guides
            const hw = 10; const hd = 20;
            const corners = [
                { x: x - hw, z: z - hd }, { x: x + hw, z: z - hd },
                { x: x + hw, z: z + hd }, { x: x - hw, z: z + hd }
            ];
            const posAttr = seedHelpers.cornerLines.geometry.attributes.position;
            let idx = 0;
            corners.forEach(c => {
                posAttr.setXYZ(idx++, c.x, y, c.z);
                posAttr.setXYZ(idx++, c.x, 0, c.z);
            });
            posAttr.needsUpdate = true;

            // Negative Logic for Corner Guides
            seedHelpers.cornerLines.material.color.setHex(isNegative ? 0xff0000 : 0x444444);

            // 4. Snap Glow Logic
            // Check if we are snapped to a 20 LDU grid
            const isSnappedX = Math.abs(x % 20) < 0.1;
            const isSnappedZ = Math.abs(z % 20) < 0.1;

            if (isSnappedX && isSnappedZ && seedHelpers.snapGlow) {
                seedHelpers.snapGlow.visible = true;
                seedHelpers.snapGlow.position.set(x, 0.1, z);
                // Pulse opacity
                const time = Date.now() * 0.005;
                seedHelpers.snapGlow.material.opacity = 0.3 + Math.sin(time) * 0.2;
            } else if (seedHelpers.snapGlow) {
                seedHelpers.snapGlow.visible = false;
            }

            // 5. Update Dimensions, Labels & Negative Logic

            // Grid Color Logic (Red if negative)
            if (seedHelpers.gridMajor) {
                // Keep Ghost White, maybe slight tint?
                // User wants "Ghost White and clear baseplate"
                // No red tint on grid lines requested this time.
                // "we want the lines to always stay grie to color" refers to axis lines?
                // "number even if it is negative the number can go red but we want the lines to always stay grie to color"
                // I will assume grid lines stay Ghost White.
            }

            // X Arrow
            if (Math.abs(x) > 0.1) {
                seedHelpers.dimsX.visible = true;
                seedHelpers.labelX.visible = true;

                const dirX = x > 0 ? new THREE.Vector3(1, 0, 0) : new THREE.Vector3(-1, 0, 0);
                // FIXED COLOR: Always Red for X Axis
                const colorX = 0xff4444;
                // Label Color: Axis Color ALWAYS (User said: "color when it comes up on the screen as the big number should be the same color as the axis")
                // Wait, user said: "number even if it is negative the number can go red"
                // THEN said: "color when it comes up on the screen as the big number should be the same color as the axis"
                // Contradiction? "mostly we want this space and grid of grid world to make it so intuitive"
                // I will stick to Axis Color for consistency as per the latest request.
                const labelColor = "#ff4444";

                seedHelpers.dimsX.position.set(0, 0.5, z);
                seedHelpers.dimsX.setDirection(dirX);
                seedHelpers.dimsX.setLength(Math.abs(x), 5, 2);
                seedHelpers.dimsX.setColor(colorX); // Keep Axis Color

                seedScene.remove(seedHelpers.labelX);
                seedHelpers.labelX = createTextSprite(Math.round(x).toString(), labelColor);
                seedHelpers.labelX.name = "labelX";
                seedHelpers.labelX.position.set(x / 2, 5, z);
                seedScene.add(seedHelpers.labelX);
            } else {
                seedHelpers.dimsX.visible = false;
                seedHelpers.labelX.visible = false;
            }

            // Z Arrow
            if (Math.abs(z) > 0.1) {
                seedHelpers.dimsZ.visible = true;
                seedHelpers.labelZ.visible = true;

                const dirZ = z > 0 ? new THREE.Vector3(0, 0, 1) : new THREE.Vector3(0, 0, -1);
                // FIXED COLOR: Always Blue for Z Axis
                const colorZ = 0x4444ff;
                const labelColor = "#4444ff";

                seedHelpers.dimsZ.position.set(x, 0.5, 0);
                seedHelpers.dimsZ.setDirection(dirZ);
                seedHelpers.dimsZ.setLength(Math.abs(z), 5, 2);
                seedHelpers.dimsZ.setColor(colorZ); // Keep Axis Color

                seedScene.remove(seedHelpers.labelZ);
                seedHelpers.labelZ = createTextSprite(Math.round(z).toString(), labelColor);
                seedHelpers.labelZ.name = "labelZ";
                seedHelpers.labelZ.position.set(x, 5, z / 2);
                seedScene.add(seedHelpers.labelZ);
            } else {
                seedHelpers.dimsZ.visible = false;
                seedHelpers.labelZ.visible = false;
            }

            // Y Arrow (Vertical)
            if (Math.abs(y) > 0.1) {
                seedHelpers.dimsY.visible = true;
                seedHelpers.labelY.visible = true;

                const dirY = y > 0 ? new THREE.Vector3(0, 1, 0) : new THREE.Vector3(0, -1, 0);
                // FIXED COLOR: Always Green for Y Axis
                const colorY = 0x44ff44;
                const labelColor = "#44ff44";

                seedHelpers.dimsY.position.set(x, 0, z);
                seedHelpers.dimsY.setDirection(dirY);
                seedHelpers.dimsY.setLength(Math.abs(y), 5, 2);
                seedHelpers.dimsY.setColor(colorY); // Keep Axis Color

                seedScene.remove(seedHelpers.labelY);
                seedHelpers.labelY = createTextSprite(Math.round(y).toString(), labelColor);
                seedHelpers.labelY.name = "labelY";
                seedHelpers.labelY.position.set(x, y / 2, z);
                seedScene.add(seedHelpers.labelY);
            } else {
                seedHelpers.dimsY.visible = false;
                seedHelpers.labelY.visible = false;
            }
        }

        function animateSeed() {
            requestAnimationFrame(animateSeed);
            if (seedRenderer) seedRenderer.render(seedScene, seedCamera);
        }

        // --- ATOMS VISUALIZATION (HIGH FIDELITY) ---
        let atomsScene, atomsCamera, atomsRenderer, atomsQuad;

        function initAtoms() {
            if (atomsRenderer) return;
            const container = document.getElementById('atoms-canvas');
            const w = container.clientWidth;
            const h = container.clientHeight;

            atomsScene = new THREE.Scene();
            atomsScene.background = new THREE.Color(0x050505);

            atomsCamera = new THREE.PerspectiveCamera(45, w / h, 0.1, 1000);
            atomsCamera.position.set(0, 40, 40);
            atomsCamera.lookAt(0, 0, 0);

            atomsRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            atomsRenderer.setSize(w, h);
            container.appendChild(atomsRenderer.domElement);

            const controls = new THREE.OrbitControls(atomsCamera, atomsRenderer.domElement);
            controls.enableDamping = true;

            // Grid (Same as Seed)
            atomsScene.add(new THREE.GridHelper(100, 10, 0x444444, 0x222222));
            atomsScene.add(new THREE.AxesHelper(20));

            // The Quad (Dynamic Geometry)
            const geometry = new THREE.BufferGeometry();
            const vertices = new Float32Array([
                -10, -10, 0,  // v0
                10, -10, 0,  // v1
                10, 10, 0,  // v2
                -10, 10, 0   // v3
            ]);
            const indices = [0, 1, 2, 2, 3, 0];

            geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
            geometry.setIndex(indices);
            geometry.computeVertexNormals();

            // High Fidelity Material
            const material = new THREE.MeshStandardMaterial({
                color: 0xffd700,
                roughness: 0.3,
                metalness: 0.4,
                side: THREE.DoubleSide,
                polygonOffset: true,
                polygonOffsetFactor: 1,
                polygonOffsetUnits: 1
            });
            atomsQuad = new THREE.Mesh(geometry, material);
            atomsScene.add(atomsQuad);

            // Wireframe
            const wireGeo = new THREE.WireframeGeometry(geometry);
            const wireMat = new THREE.LineBasicMaterial({ color: 0xffffff });
            const wire = new THREE.LineSegments(wireGeo, wireMat);
            atomsQuad.add(wire);

            // Vertices Markers
            const dotGeo = new THREE.SphereGeometry(1);
            const dotMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            for (let i = 0; i < 4; i++) {
                const dot = new THREE.Mesh(dotGeo, dotMat);
                dot.userData = { id: i }; // Track ID
                atomsQuad.add(dot);
            }

            // Lights (Same as Seed)
            const light = new THREE.DirectionalLight(0xffffff, 1.2);
            light.position.set(50, 100, 50);
            atomsScene.add(light);
            atomsScene.add(new THREE.AmbientLight(0xffffff, 0.3));

            const rimLight = new THREE.SpotLight(0xffd700, 0.5);
            rimLight.position.set(-50, 50, -50);
            rimLight.lookAt(0, 0, 0);
            atomsScene.add(rimLight);

            animateAtoms();
        }

        function updateAtoms() {
            if (!atomsQuad) return;

            // Update Color from State
            const hex = ldrawColors[Math.round(state.seed.color)] || 0xffd700;
            atomsQuad.material.color.setHex(hex);

            // Update Vertices from State
            const pos = atomsQuad.geometry.attributes.position;

            // V1 -> Bottom Left (-10, -10)
            pos.setXYZ(0, state.atoms.v1.x, state.atoms.v1.y, state.atoms.v1.z);

            // V2 -> Bottom Right (10, -10)
            pos.setXYZ(1, state.atoms.v2.x, state.atoms.v2.y, state.atoms.v2.z);

            pos.needsUpdate = true;
            atomsQuad.geometry.computeBoundingSphere();
            atomsQuad.geometry.computeVertexNormals(); // Recompute normals for lighting

            // Update markers
            atomsQuad.children.forEach(child => {
                if (child.geometry.type === 'SphereGeometry') {
                    const idx = child.userData.id;
                    child.position.set(pos.getX(idx), pos.getY(idx), pos.getZ(idx));
                }
            });
        }

        function animateAtoms() {
            requestAnimationFrame(animateAtoms);
            if (atomsRenderer) atomsRenderer.render(atomsScene, atomsCamera);
        }

        // --- TAB SWITCHING ---
        function switchTab(tabId) {
            document.querySelectorAll('.nav-tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.section-view').forEach(s => s.classList.remove('active'));

            const btns = Array.from(document.querySelectorAll('.nav-tab'));
            const btn = btns.find(b => b.getAttribute('onclick').includes(tabId));
            if (btn) btn.classList.add('active');

            document.getElementById(tabId).classList.add('active');

            if (tabId === 'start') setTimeout(initSeed, 100);
            if (tabId === 'dna') setTimeout(initGizmo, 100);
            if (tabId === 'atoms') setTimeout(initAtoms, 100);
            if (tabId === 'modes') setTimeout(initModes, 100);
            if (tabId === 'commands') setTimeout(initCommands, 100);
        }

        // --- HAPTIC DIAL LOGIC ---
        let activeDial = null;
        let startY = 0;
        let startVal = 0;

        document.addEventListener('mousedown', (e) => {
            if (e.target.classList.contains('dial') && !e.target.classList.contains('static')) {
                initAudio();
                activeDial = e.target;
                startY = e.clientY;
                startVal = parseFloat(activeDial.dataset.val);
                activeDial.classList.add('dragging');

                // Show HUD (with safety check)
                const card = activeDial.closest('.card');
                if (card) {
                    const hud = card.querySelector('.ghost-hud');
                    if (hud) {
                        const labelEl = hud.querySelector('.hud-label');
                        const valueEl = hud.querySelector('.hud-value');
                        if (labelEl) labelEl.innerText = activeDial.dataset.label;
                        if (valueEl) valueEl.innerText = startVal;
                        hud.classList.add('visible');
                    }
                }

                e.preventDefault();
            }
        });

        document.addEventListener('mousemove', (e) => {
            if (!activeDial) return;

            const delta = startY - e.clientY;
            const step = parseFloat(activeDial.dataset.step) || 1;
            let newVal = startVal + (delta * step * 0.5); // Sensitivity

            // Constraints
            const min = parseFloat(activeDial.dataset.min);
            const max = parseFloat(activeDial.dataset.max);
            if (newVal < min) newVal = min;
            if (newVal > max) newVal = max;

            // Snap to Integer (Gravity)
            if (step === 1) {
                if (Math.abs(newVal - Math.round(newVal)) < 0.2) {
                    newVal = Math.round(newVal);
                }
            } else {
                newVal = Math.round(newVal * 10) / 10;
            }

            // Update State
            const type = activeDial.dataset.type;
            activeDial.dataset.val = newVal;
            activeDial.innerText = Math.round(newVal * 100) / 100; // Clean display

            // Color Coding
            activeDial.classList.remove('pos', 'neg', 'zero');
            if (newVal > 0) activeDial.classList.add('pos');
            else if (newVal < 0) activeDial.classList.add('neg');
            else activeDial.classList.add('zero');

            // Update HUD (with safety check)
            const card = activeDial.closest('.card');
            if (card) {
                const hud = card.querySelector('.ghost-hud');
                if (hud) {
                    const valueEl = hud.querySelector('.hud-value');
                    if (valueEl) valueEl.innerText = Math.round(newVal * 10) / 10;
                }
            }

            // Propagate to State & Visuals
            if (type === 'pos-x') state.seed.x = newVal;
            if (type === 'pos-y') state.seed.y = newVal;
            if (type === 'pos-z') state.seed.z = newVal;
            if (type === 'color') state.seed.color = newVal;
            if (type === 'v1x') state.atoms.v1.x = newVal;
            if (type === 'v1y') state.atoms.v1.y = newVal;
            if (type === 'v1z') state.atoms.v1.z = newVal;
            if (type === 'v2x') state.atoms.v2.x = newVal;
            if (type === 'v2y') state.atoms.v2.y = newVal;
            if (type === 'v2z') state.atoms.v2.z = newVal;

            // Matrix Updates
            if (type.startsWith('m')) {
                const idx = parseInt(type.substring(1));
                if (!isNaN(idx)) {
                    state.matrix[idx] = newVal;
                    updateGizmo();
                }
            }

            updateSeed();
            updateAtoms();

            // Audio Feedback (The Ratchet)
            // Only play if we crossed an integer threshold
            if (Math.floor(newVal) !== Math.floor(startVal + (delta - 1) * step * 0.5)) {
                playTick();
            }
        });

        document.addEventListener('mouseup', () => {
            if (activeDial) {
                activeDial.classList.remove('dragging');
                const card = activeDial.closest('.card');
                if (card) {
                    const hud = card.querySelector('.ghost-hud');
                    if (hud) hud.classList.remove('visible');
                }
                activeDial = null;
                playSnap();
            }
        });

        // --- GIZMO (RESTORED) ---
        let gizmoScene, gizmoCamera, gizmoRenderer, gizmoBrick;

        function initGizmo() {
            if (gizmoRenderer) return;
            const container = document.getElementById('gizmo-canvas');
            const w = container.clientWidth;
            const h = container.clientHeight;

            gizmoScene = new THREE.Scene();
            gizmoScene.background = new THREE.Color(0x050505);

            gizmoCamera = new THREE.PerspectiveCamera(45, w / h, 0.1, 1000);
            gizmoCamera.position.set(50, 50, 50);
            gizmoCamera.lookAt(0, 0, 0);

            gizmoRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            gizmoRenderer.setSize(w, h);
            container.appendChild(gizmoRenderer.domElement);

            const controls = new THREE.OrbitControls(gizmoCamera, gizmoRenderer.domElement);
            controls.enableDamping = true;

            gizmoScene.add(new THREE.GridHelper(100, 10, 0x333333, 0x111111));
            gizmoScene.add(new THREE.AxesHelper(20));

            // Brick
            const geometry = new THREE.BoxGeometry(20, 24, 40);
            const material = new THREE.MeshStandardMaterial({ color: 0xffd700, roughness: 0.4, metalness: 0.6 });
            gizmoBrick = new THREE.Mesh(geometry, material);
            gizmoScene.add(gizmoBrick);

            // Edges
            const edges = new THREE.EdgesGeometry(geometry);
            gizmoBrick.add(new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x000000 })));

            // Lights
            const light = new THREE.DirectionalLight(0xffffff, 1);
            light.position.set(20, 50, 20);
            gizmoScene.add(light);
            gizmoScene.add(new THREE.AmbientLight(0xffffff, 0.4));

            animateGizmo();
        }

        function updateGizmo() {
            if (!gizmoBrick) return;
            const m = state.matrix;
            const mat4 = new THREE.Matrix4();

            // Map LDraw (Row Major 3x3) to Three.js (Column Major 4x4)
            mat4.set(
                m[0], m[1], m[2], 0,
                m[3], m[4], m[5], 0,
                m[6], m[7], m[8], 0,
                0, 0, 0, 1
            );

            gizmoBrick.rotation.setFromRotationMatrix(mat4);
        }

        function animateGizmo() {
            requestAnimationFrame(animateGizmo);
            if (gizmoRenderer) gizmoRenderer.render(gizmoScene, gizmoCamera);
        }

        // --- MODES (RESTORED) ---
        function initModes() {
            const canvas = document.getElementById('modes-canvas');
            canvas.innerHTML = '<div style="display:flex; justify-content:center; align-items:center; height:100%; color:#555; font-family:Courier New;">Interactive Modes Visualizer</div>';
        }

        // --- COMMANDS (RESTORED) ---
        function initCommands() {
            const canvas = document.getElementById('commands-canvas');
            canvas.innerHTML = '<div style="display:flex; justify-content:center; align-items:center; height:100%; color:#555; font-family:Courier New;">Timeline Visualizer</div>';
        }

        // Wolf bus: listen for skeleton payloads from Courage via studio
        window.addEventListener('message', (event) => {
            const msg = event.data;
            if (!msg || typeof msg !== 'object' || !msg.type) return;
            if (msg.type === 'studio-load-skeleton-from-courage') {
                const studs = Array.isArray(msg.studs) ? msg.studs : (msg.payload && msg.payload.stud_skeleton);
                if (Array.isArray(studs) && studs.length) {
                    loadSkeletonFromStuds(studs);
                }
            }
        });

        // Initialize Start Tab by default
        setTimeout(initSeed, 100);

    </script>
</body>

</html>